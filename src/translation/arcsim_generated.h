// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ARCSIM_ARCSIM_H_
#define FLATBUFFERS_GENERATED_ARCSIM_ARCSIM_H_

#include "flatbuffers/flatbuffers.h"

namespace ARCSim {

struct Vec3;

struct Vec2;

struct GeometryDataVertex;
struct GeometryDataVertexT;

struct GeometryDataFace;
struct GeometryDataFaceT;

struct Triangle;

struct Face;
struct FaceT;

struct Curve;
struct CurveT;

struct WorldSpaceCoordinates;
struct WorldSpaceCoordinatesT;

struct MaterialSpaceCoordinates;
struct MaterialSpaceCoordinatesT;

struct Geometry;
struct GeometryT;

struct Fold;
struct FoldT;

struct CurveMap;
struct CurveMapT;

struct PieceMap;
struct PieceMapT;

struct Piece;
struct PieceT;

struct Seam;
struct SeamT;

struct AvametricV1Fabric;
struct AvametricV1FabricT;

struct GerberFabric;
struct GerberFabricT;

struct SimpleAnisotropicFabric;
struct SimpleAnisotropicFabricT;

struct Fabric;
struct FabricT;

struct GarmentFrame;
struct GarmentFrameT;

struct Garment;
struct GarmentT;

struct Sdf;
struct SdfT;

struct ObstacleFrame;
struct ObstacleFrameT;

struct Obstacle;
struct ObstacleT;

struct StandardConstraintProperties;
struct StandardConstraintPropertiesT;

struct AttachmentNode;

struct AttachmentsNode;
struct AttachmentsNodeT;

struct AttachmentEdge;

struct AttachmentsEdge;
struct AttachmentsEdgeT;

struct AttachmentMs;
struct AttachmentMsT;

struct AttachmentsMs;
struct AttachmentsMsT;

struct AttachmentWs;
struct AttachmentWsT;

struct AttachmentsWs;
struct AttachmentsWsT;

struct AttachmentUV;
struct AttachmentUVT;

struct AttachmentsUV;
struct AttachmentsUVT;

struct AttachmentBary;
struct AttachmentBaryT;

struct AttachmentsBary;
struct AttachmentsBaryT;

struct NodeConstraint;
struct NodeConstraintT;

struct ForceConstraint;
struct ForceConstraintT;

struct PinConstraint;
struct PinConstraintT;

struct CenteringConstraint;
struct CenteringConstraintT;

struct BarrierConstraint;
struct BarrierConstraintT;

struct BeltConstraint;
struct BeltConstraintT;

struct ElasticConstraint;
struct ElasticConstraintT;

struct ButtonConstraint;
struct ButtonConstraintT;

struct OrientedButtonConstraint;
struct OrientedButtonConstraintT;

struct Constraint;
struct ConstraintT;

struct SimulationProperties;
struct SimulationPropertiesT;

struct StichingProperties;
struct StichingPropertiesT;

struct MeshingProperties;
struct MeshingPropertiesT;

struct Scene;
struct SceneT;

enum class VertexDataType : int8_t {
  CollisionDistance = 0,
  Marked = 1,
  MIN = CollisionDistance,
  MAX = Marked
};

inline const VertexDataType (&EnumValuesVertexDataType())[2] {
  static const VertexDataType values[] = {
    VertexDataType::CollisionDistance,
    VertexDataType::Marked
  };
  return values;
}

inline const char * const *EnumNamesVertexDataType() {
  static const char * const names[] = {
    "CollisionDistance",
    "Marked",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexDataType(VertexDataType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesVertexDataType()[index];
}

enum class FaceDataType : int8_t {
  Strain = 0,
  Curvature = 1,
  StretchEnergy = 2,
  BendEnergy = 3,
  Flag = 4,
  MIN = Strain,
  MAX = Flag
};

inline const FaceDataType (&EnumValuesFaceDataType())[5] {
  static const FaceDataType values[] = {
    FaceDataType::Strain,
    FaceDataType::Curvature,
    FaceDataType::StretchEnergy,
    FaceDataType::BendEnergy,
    FaceDataType::Flag
  };
  return values;
}

inline const char * const *EnumNamesFaceDataType() {
  static const char * const names[] = {
    "Strain",
    "Curvature",
    "StretchEnergy",
    "BendEnergy",
    "Flag",
    nullptr
  };
  return names;
}

inline const char *EnumNameFaceDataType(FaceDataType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFaceDataType()[index];
}

enum class CurveType : int8_t {
  Polyline = 0,
  Bezier = 1,
  MIN = Polyline,
  MAX = Bezier
};

inline const CurveType (&EnumValuesCurveType())[2] {
  static const CurveType values[] = {
    CurveType::Polyline,
    CurveType::Bezier
  };
  return values;
}

inline const char * const *EnumNamesCurveType() {
  static const char * const names[] = {
    "Polyline",
    "Bezier",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurveType(CurveType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCurveType()[index];
}

enum class EdgeTreatment : int8_t {
  Round = 0,
  Block = 1,
  DoubleRound = 2,
  MIN = Round,
  MAX = DoubleRound
};

inline const EdgeTreatment (&EnumValuesEdgeTreatment())[3] {
  static const EdgeTreatment values[] = {
    EdgeTreatment::Round,
    EdgeTreatment::Block,
    EdgeTreatment::DoubleRound
  };
  return values;
}

inline const char * const *EnumNamesEdgeTreatment() {
  static const char * const names[] = {
    "Round",
    "Block",
    "DoubleRound",
    nullptr
  };
  return names;
}

inline const char *EnumNameEdgeTreatment(EdgeTreatment e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEdgeTreatment()[index];
}

enum class FoldType : int8_t {
  Simple = 0,
  Graduated = 1,
  MIN = Simple,
  MAX = Graduated
};

inline const FoldType (&EnumValuesFoldType())[2] {
  static const FoldType values[] = {
    FoldType::Simple,
    FoldType::Graduated
  };
  return values;
}

inline const char * const *EnumNamesFoldType() {
  static const char * const names[] = {
    "Simple",
    "Graduated",
    nullptr
  };
  return names;
}

inline const char *EnumNameFoldType(FoldType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFoldType()[index];
}

enum class FabricType : int8_t {
  AvametricV1 = 0,
  Gerber = 1,
  SimpleAnisotropic = 2,
  MIN = AvametricV1,
  MAX = SimpleAnisotropic
};

inline const FabricType (&EnumValuesFabricType())[3] {
  static const FabricType values[] = {
    FabricType::AvametricV1,
    FabricType::Gerber,
    FabricType::SimpleAnisotropic
  };
  return values;
}

inline const char * const *EnumNamesFabricType() {
  static const char * const names[] = {
    "AvametricV1",
    "Gerber",
    "SimpleAnisotropic",
    nullptr
  };
  return names;
}

inline const char *EnumNameFabricType(FabricType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFabricType()[index];
}

enum class AvametricBaseMaterial : int8_t {
  GrayInterlock = 0,
  BlackDenim11oz = 1,
  IvoryRibKnit = 2,
  PinkRibbonBrown = 3,
  Aluminium = 4,
  RoyalTarget = 5,
  CamelPonteRoma = 6,
  TangoRedJetSet = 7,
  WhiteDotsOnBlk = 8,
  WhiteSwimSolid = 9,
  Isotropic = 10,
  NavySparkleSweat = 11,
  MIN = GrayInterlock,
  MAX = NavySparkleSweat
};

inline const AvametricBaseMaterial (&EnumValuesAvametricBaseMaterial())[12] {
  static const AvametricBaseMaterial values[] = {
    AvametricBaseMaterial::GrayInterlock,
    AvametricBaseMaterial::BlackDenim11oz,
    AvametricBaseMaterial::IvoryRibKnit,
    AvametricBaseMaterial::PinkRibbonBrown,
    AvametricBaseMaterial::Aluminium,
    AvametricBaseMaterial::RoyalTarget,
    AvametricBaseMaterial::CamelPonteRoma,
    AvametricBaseMaterial::TangoRedJetSet,
    AvametricBaseMaterial::WhiteDotsOnBlk,
    AvametricBaseMaterial::WhiteSwimSolid,
    AvametricBaseMaterial::Isotropic,
    AvametricBaseMaterial::NavySparkleSweat
  };
  return values;
}

inline const char * const *EnumNamesAvametricBaseMaterial() {
  static const char * const names[] = {
    "GrayInterlock",
    "BlackDenim11oz",
    "IvoryRibKnit",
    "PinkRibbonBrown",
    "Aluminium",
    "RoyalTarget",
    "CamelPonteRoma",
    "TangoRedJetSet",
    "WhiteDotsOnBlk",
    "WhiteSwimSolid",
    "Isotropic",
    "NavySparkleSweat",
    nullptr
  };
  return names;
}

inline const char *EnumNameAvametricBaseMaterial(AvametricBaseMaterial e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAvametricBaseMaterial()[index];
}

enum class AnyAttachment : uint8_t {
  NONE = 0,
  AttachmentsNode = 1,
  AttachmentsEdge = 2,
  AttachmentsMs = 3,
  AttachmentsWs = 4,
  AttachmentsUV = 5,
  AttachmentsBary = 6,
  MIN = NONE,
  MAX = AttachmentsBary
};

inline const AnyAttachment (&EnumValuesAnyAttachment())[7] {
  static const AnyAttachment values[] = {
    AnyAttachment::NONE,
    AnyAttachment::AttachmentsNode,
    AnyAttachment::AttachmentsEdge,
    AnyAttachment::AttachmentsMs,
    AnyAttachment::AttachmentsWs,
    AnyAttachment::AttachmentsUV,
    AnyAttachment::AttachmentsBary
  };
  return values;
}

inline const char * const *EnumNamesAnyAttachment() {
  static const char * const names[] = {
    "NONE",
    "AttachmentsNode",
    "AttachmentsEdge",
    "AttachmentsMs",
    "AttachmentsWs",
    "AttachmentsUV",
    "AttachmentsBary",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyAttachment(AnyAttachment e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAnyAttachment()[index];
}

template<typename T> struct AnyAttachmentTraits {
  static const AnyAttachment enum_value = AnyAttachment::NONE;
};

template<> struct AnyAttachmentTraits<AttachmentsNode> {
  static const AnyAttachment enum_value = AnyAttachment::AttachmentsNode;
};

template<> struct AnyAttachmentTraits<AttachmentsEdge> {
  static const AnyAttachment enum_value = AnyAttachment::AttachmentsEdge;
};

template<> struct AnyAttachmentTraits<AttachmentsMs> {
  static const AnyAttachment enum_value = AnyAttachment::AttachmentsMs;
};

template<> struct AnyAttachmentTraits<AttachmentsWs> {
  static const AnyAttachment enum_value = AnyAttachment::AttachmentsWs;
};

template<> struct AnyAttachmentTraits<AttachmentsUV> {
  static const AnyAttachment enum_value = AnyAttachment::AttachmentsUV;
};

template<> struct AnyAttachmentTraits<AttachmentsBary> {
  static const AnyAttachment enum_value = AnyAttachment::AttachmentsBary;
};

struct AnyAttachmentUnion {
  AnyAttachment type;
  void *value;

  AnyAttachmentUnion() : type(AnyAttachment::NONE), value(nullptr) {}
  AnyAttachmentUnion(AnyAttachmentUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AnyAttachment::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AnyAttachmentUnion(const AnyAttachmentUnion &) FLATBUFFERS_NOEXCEPT;
  AnyAttachmentUnion &operator=(const AnyAttachmentUnion &u) FLATBUFFERS_NOEXCEPT
    { AnyAttachmentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AnyAttachmentUnion &operator=(AnyAttachmentUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AnyAttachmentUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = AnyAttachmentTraits<typename T::TableType>::enum_value;
    if (type != AnyAttachment::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AnyAttachment type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AttachmentsNodeT *AsAttachmentsNode() {
    return type == AnyAttachment::AttachmentsNode ?
      reinterpret_cast<AttachmentsNodeT *>(value) : nullptr;
  }
  const AttachmentsNodeT *AsAttachmentsNode() const {
    return type == AnyAttachment::AttachmentsNode ?
      reinterpret_cast<const AttachmentsNodeT *>(value) : nullptr;
  }
  AttachmentsEdgeT *AsAttachmentsEdge() {
    return type == AnyAttachment::AttachmentsEdge ?
      reinterpret_cast<AttachmentsEdgeT *>(value) : nullptr;
  }
  const AttachmentsEdgeT *AsAttachmentsEdge() const {
    return type == AnyAttachment::AttachmentsEdge ?
      reinterpret_cast<const AttachmentsEdgeT *>(value) : nullptr;
  }
  AttachmentsMsT *AsAttachmentsMs() {
    return type == AnyAttachment::AttachmentsMs ?
      reinterpret_cast<AttachmentsMsT *>(value) : nullptr;
  }
  const AttachmentsMsT *AsAttachmentsMs() const {
    return type == AnyAttachment::AttachmentsMs ?
      reinterpret_cast<const AttachmentsMsT *>(value) : nullptr;
  }
  AttachmentsWsT *AsAttachmentsWs() {
    return type == AnyAttachment::AttachmentsWs ?
      reinterpret_cast<AttachmentsWsT *>(value) : nullptr;
  }
  const AttachmentsWsT *AsAttachmentsWs() const {
    return type == AnyAttachment::AttachmentsWs ?
      reinterpret_cast<const AttachmentsWsT *>(value) : nullptr;
  }
  AttachmentsUVT *AsAttachmentsUV() {
    return type == AnyAttachment::AttachmentsUV ?
      reinterpret_cast<AttachmentsUVT *>(value) : nullptr;
  }
  const AttachmentsUVT *AsAttachmentsUV() const {
    return type == AnyAttachment::AttachmentsUV ?
      reinterpret_cast<const AttachmentsUVT *>(value) : nullptr;
  }
  AttachmentsBaryT *AsAttachmentsBary() {
    return type == AnyAttachment::AttachmentsBary ?
      reinterpret_cast<AttachmentsBaryT *>(value) : nullptr;
  }
  const AttachmentsBaryT *AsAttachmentsBary() const {
    return type == AnyAttachment::AttachmentsBary ?
      reinterpret_cast<const AttachmentsBaryT *>(value) : nullptr;
  }
};

bool VerifyAnyAttachment(flatbuffers::Verifier &verifier, const void *obj, AnyAttachment type);
bool VerifyAnyAttachmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ClothAttachment : uint8_t {
  NONE = 0,
  AttachmentsEdge = 1,
  AttachmentsMs = 2,
  MIN = NONE,
  MAX = AttachmentsMs
};

inline const ClothAttachment (&EnumValuesClothAttachment())[3] {
  static const ClothAttachment values[] = {
    ClothAttachment::NONE,
    ClothAttachment::AttachmentsEdge,
    ClothAttachment::AttachmentsMs
  };
  return values;
}

inline const char * const *EnumNamesClothAttachment() {
  static const char * const names[] = {
    "NONE",
    "AttachmentsEdge",
    "AttachmentsMs",
    nullptr
  };
  return names;
}

inline const char *EnumNameClothAttachment(ClothAttachment e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesClothAttachment()[index];
}

template<typename T> struct ClothAttachmentTraits {
  static const ClothAttachment enum_value = ClothAttachment::NONE;
};

template<> struct ClothAttachmentTraits<AttachmentsEdge> {
  static const ClothAttachment enum_value = ClothAttachment::AttachmentsEdge;
};

template<> struct ClothAttachmentTraits<AttachmentsMs> {
  static const ClothAttachment enum_value = ClothAttachment::AttachmentsMs;
};

struct ClothAttachmentUnion {
  ClothAttachment type;
  void *value;

  ClothAttachmentUnion() : type(ClothAttachment::NONE), value(nullptr) {}
  ClothAttachmentUnion(ClothAttachmentUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ClothAttachment::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ClothAttachmentUnion(const ClothAttachmentUnion &) FLATBUFFERS_NOEXCEPT;
  ClothAttachmentUnion &operator=(const ClothAttachmentUnion &u) FLATBUFFERS_NOEXCEPT
    { ClothAttachmentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ClothAttachmentUnion &operator=(ClothAttachmentUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ClothAttachmentUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ClothAttachmentTraits<typename T::TableType>::enum_value;
    if (type != ClothAttachment::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ClothAttachment type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AttachmentsEdgeT *AsAttachmentsEdge() {
    return type == ClothAttachment::AttachmentsEdge ?
      reinterpret_cast<AttachmentsEdgeT *>(value) : nullptr;
  }
  const AttachmentsEdgeT *AsAttachmentsEdge() const {
    return type == ClothAttachment::AttachmentsEdge ?
      reinterpret_cast<const AttachmentsEdgeT *>(value) : nullptr;
  }
  AttachmentsMsT *AsAttachmentsMs() {
    return type == ClothAttachment::AttachmentsMs ?
      reinterpret_cast<AttachmentsMsT *>(value) : nullptr;
  }
  const AttachmentsMsT *AsAttachmentsMs() const {
    return type == ClothAttachment::AttachmentsMs ?
      reinterpret_cast<const AttachmentsMsT *>(value) : nullptr;
  }
};

bool VerifyClothAttachment(flatbuffers::Verifier &verifier, const void *obj, ClothAttachment type);
bool VerifyClothAttachmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ObstacleAttachment : uint8_t {
  NONE = 0,
  AttachmentsUV = 1,
  AttachmentsBary = 2,
  MIN = NONE,
  MAX = AttachmentsBary
};

inline const ObstacleAttachment (&EnumValuesObstacleAttachment())[3] {
  static const ObstacleAttachment values[] = {
    ObstacleAttachment::NONE,
    ObstacleAttachment::AttachmentsUV,
    ObstacleAttachment::AttachmentsBary
  };
  return values;
}

inline const char * const *EnumNamesObstacleAttachment() {
  static const char * const names[] = {
    "NONE",
    "AttachmentsUV",
    "AttachmentsBary",
    nullptr
  };
  return names;
}

inline const char *EnumNameObstacleAttachment(ObstacleAttachment e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObstacleAttachment()[index];
}

template<typename T> struct ObstacleAttachmentTraits {
  static const ObstacleAttachment enum_value = ObstacleAttachment::NONE;
};

template<> struct ObstacleAttachmentTraits<AttachmentsUV> {
  static const ObstacleAttachment enum_value = ObstacleAttachment::AttachmentsUV;
};

template<> struct ObstacleAttachmentTraits<AttachmentsBary> {
  static const ObstacleAttachment enum_value = ObstacleAttachment::AttachmentsBary;
};

struct ObstacleAttachmentUnion {
  ObstacleAttachment type;
  void *value;

  ObstacleAttachmentUnion() : type(ObstacleAttachment::NONE), value(nullptr) {}
  ObstacleAttachmentUnion(ObstacleAttachmentUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ObstacleAttachment::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ObstacleAttachmentUnion(const ObstacleAttachmentUnion &) FLATBUFFERS_NOEXCEPT;
  ObstacleAttachmentUnion &operator=(const ObstacleAttachmentUnion &u) FLATBUFFERS_NOEXCEPT
    { ObstacleAttachmentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ObstacleAttachmentUnion &operator=(ObstacleAttachmentUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ObstacleAttachmentUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ObstacleAttachmentTraits<typename T::TableType>::enum_value;
    if (type != ObstacleAttachment::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ObstacleAttachment type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AttachmentsUVT *AsAttachmentsUV() {
    return type == ObstacleAttachment::AttachmentsUV ?
      reinterpret_cast<AttachmentsUVT *>(value) : nullptr;
  }
  const AttachmentsUVT *AsAttachmentsUV() const {
    return type == ObstacleAttachment::AttachmentsUV ?
      reinterpret_cast<const AttachmentsUVT *>(value) : nullptr;
  }
  AttachmentsBaryT *AsAttachmentsBary() {
    return type == ObstacleAttachment::AttachmentsBary ?
      reinterpret_cast<AttachmentsBaryT *>(value) : nullptr;
  }
  const AttachmentsBaryT *AsAttachmentsBary() const {
    return type == ObstacleAttachment::AttachmentsBary ?
      reinterpret_cast<const AttachmentsBaryT *>(value) : nullptr;
  }
};

bool VerifyObstacleAttachment(flatbuffers::Verifier &verifier, const void *obj, ObstacleAttachment type);
bool VerifyObstacleAttachmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ConstraintType : int8_t {
  Node = 0,
  Force = 1,
  Pin = 2,
  Centering = 3,
  Barrier = 4,
  Belt = 5,
  Elastic = 6,
  Button = 7,
  OrientedButton = 8,
  MIN = Node,
  MAX = OrientedButton
};

inline const ConstraintType (&EnumValuesConstraintType())[9] {
  static const ConstraintType values[] = {
    ConstraintType::Node,
    ConstraintType::Force,
    ConstraintType::Pin,
    ConstraintType::Centering,
    ConstraintType::Barrier,
    ConstraintType::Belt,
    ConstraintType::Elastic,
    ConstraintType::Button,
    ConstraintType::OrientedButton
  };
  return values;
}

inline const char * const *EnumNamesConstraintType() {
  static const char * const names[] = {
    "Node",
    "Force",
    "Pin",
    "Centering",
    "Barrier",
    "Belt",
    "Elastic",
    "Button",
    "OrientedButton",
    nullptr
  };
  return names;
}

inline const char *EnumNameConstraintType(ConstraintType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConstraintType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Vec3";
  }
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float u_;
  float v_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Vec2";
  }
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(float _u, float _v)
      : u_(flatbuffers::EndianScalar(_u)),
        v_(flatbuffers::EndianScalar(_v)) {
  }
  float u() const {
    return flatbuffers::EndianScalar(u_);
  }
  float v() const {
    return flatbuffers::EndianScalar(v_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Triangle FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t a_;
  uint32_t b_;
  uint32_t c_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Triangle";
  }
  Triangle() {
    memset(this, 0, sizeof(Triangle));
  }
  Triangle(uint32_t _a, uint32_t _b, uint32_t _c)
      : a_(flatbuffers::EndianScalar(_a)),
        b_(flatbuffers::EndianScalar(_b)),
        c_(flatbuffers::EndianScalar(_c)) {
  }
  uint32_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
  uint32_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  uint32_t c() const {
    return flatbuffers::EndianScalar(c_);
  }
};
FLATBUFFERS_STRUCT_END(Triangle, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AttachmentNode FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t vertex_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentNode";
  }
  AttachmentNode() {
    memset(this, 0, sizeof(AttachmentNode));
  }
  AttachmentNode(uint32_t _vertex)
      : vertex_(flatbuffers::EndianScalar(_vertex)) {
  }
  uint32_t vertex() const {
    return flatbuffers::EndianScalar(vertex_);
  }
};
FLATBUFFERS_STRUCT_END(AttachmentNode, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AttachmentEdge FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t peice_;
  uint32_t curve_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentEdge";
  }
  AttachmentEdge() {
    memset(this, 0, sizeof(AttachmentEdge));
  }
  AttachmentEdge(uint32_t _peice, uint32_t _curve)
      : peice_(flatbuffers::EndianScalar(_peice)),
        curve_(flatbuffers::EndianScalar(_curve)) {
  }
  uint32_t peice() const {
    return flatbuffers::EndianScalar(peice_);
  }
  uint32_t curve() const {
    return flatbuffers::EndianScalar(curve_);
  }
};
FLATBUFFERS_STRUCT_END(AttachmentEdge, 8);

struct GeometryDataVertexT : public flatbuffers::NativeTable {
  typedef GeometryDataVertex TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GeometryDataVertexT";
  }
  VertexDataType type;
  std::vector<uint32_t> vertices_ws;
  GeometryDataVertexT()
      : type(VertexDataType::CollisionDistance) {
  }
};

struct GeometryDataVertex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryDataVertexT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GeometryDataVertex";
  }
  enum {
    VT_TYPE = 4,
    VT_VERTICES_WS = 6
  };
  VertexDataType type() const {
    return static_cast<VertexDataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint32_t> *vertices_ws() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_VERTICES_WS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_VERTICES_WS) &&
           verifier.Verify(vertices_ws()) &&
           verifier.EndTable();
  }
  GeometryDataVertexT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeometryDataVertexT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeometryDataVertex> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataVertexT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeometryDataVertexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(VertexDataType type) {
    fbb_.AddElement<int8_t>(GeometryDataVertex::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_vertices_ws(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> vertices_ws) {
    fbb_.AddOffset(GeometryDataVertex::VT_VERTICES_WS, vertices_ws);
  }
  explicit GeometryDataVertexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryDataVertexBuilder &operator=(const GeometryDataVertexBuilder &);
  flatbuffers::Offset<GeometryDataVertex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryDataVertex>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryDataVertex> CreateGeometryDataVertex(
    flatbuffers::FlatBufferBuilder &_fbb,
    VertexDataType type = VertexDataType::CollisionDistance,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> vertices_ws = 0) {
  GeometryDataVertexBuilder builder_(_fbb);
  builder_.add_vertices_ws(vertices_ws);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeometryDataVertex> CreateGeometryDataVertexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    VertexDataType type = VertexDataType::CollisionDistance,
    const std::vector<uint32_t> *vertices_ws = nullptr) {
  return ARCSim::CreateGeometryDataVertex(
      _fbb,
      type,
      vertices_ws ? _fbb.CreateVector<uint32_t>(*vertices_ws) : 0);
}

flatbuffers::Offset<GeometryDataVertex> CreateGeometryDataVertex(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataVertexT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeometryDataFaceT : public flatbuffers::NativeTable {
  typedef GeometryDataFace TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GeometryDataFaceT";
  }
  FaceDataType type;
  std::vector<uint32_t> faces;
  GeometryDataFaceT()
      : type(FaceDataType::Strain) {
  }
};

struct GeometryDataFace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryDataFaceT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GeometryDataFace";
  }
  enum {
    VT_TYPE = 4,
    VT_FACES = 6
  };
  FaceDataType type() const {
    return static_cast<FaceDataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint32_t> *faces() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_FACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FACES) &&
           verifier.Verify(faces()) &&
           verifier.EndTable();
  }
  GeometryDataFaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeometryDataFaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeometryDataFace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataFaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeometryDataFaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(FaceDataType type) {
    fbb_.AddElement<int8_t>(GeometryDataFace::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_faces(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> faces) {
    fbb_.AddOffset(GeometryDataFace::VT_FACES, faces);
  }
  explicit GeometryDataFaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryDataFaceBuilder &operator=(const GeometryDataFaceBuilder &);
  flatbuffers::Offset<GeometryDataFace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryDataFace>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryDataFace> CreateGeometryDataFace(
    flatbuffers::FlatBufferBuilder &_fbb,
    FaceDataType type = FaceDataType::Strain,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> faces = 0) {
  GeometryDataFaceBuilder builder_(_fbb);
  builder_.add_faces(faces);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeometryDataFace> CreateGeometryDataFaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FaceDataType type = FaceDataType::Strain,
    const std::vector<uint32_t> *faces = nullptr) {
  return ARCSim::CreateGeometryDataFace(
      _fbb,
      type,
      faces ? _fbb.CreateVector<uint32_t>(*faces) : 0);
}

flatbuffers::Offset<GeometryDataFace> CreateGeometryDataFace(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataFaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FaceT : public flatbuffers::NativeTable {
  typedef Face TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.FaceT";
  }
  std::unique_ptr<Triangle> tri_ws;
  std::unique_ptr<Triangle> tri_ms;
  std::vector<Triangle> tri_tx_chns;
  FaceT() {
  }
};

struct Face FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FaceT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Face";
  }
  enum {
    VT_TRI_WS = 4,
    VT_TRI_MS = 6,
    VT_TRI_TX_CHNS = 8
  };
  const Triangle *tri_ws() const {
    return GetStruct<const Triangle *>(VT_TRI_WS);
  }
  const Triangle *tri_ms() const {
    return GetStruct<const Triangle *>(VT_TRI_MS);
  }
  const flatbuffers::Vector<const Triangle *> *tri_tx_chns() const {
    return GetPointer<const flatbuffers::Vector<const Triangle *> *>(VT_TRI_TX_CHNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Triangle>(verifier, VT_TRI_WS) &&
           VerifyFieldRequired<Triangle>(verifier, VT_TRI_MS) &&
           VerifyOffset(verifier, VT_TRI_TX_CHNS) &&
           verifier.Verify(tri_tx_chns()) &&
           verifier.EndTable();
  }
  FaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Face> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tri_ws(const Triangle *tri_ws) {
    fbb_.AddStruct(Face::VT_TRI_WS, tri_ws);
  }
  void add_tri_ms(const Triangle *tri_ms) {
    fbb_.AddStruct(Face::VT_TRI_MS, tri_ms);
  }
  void add_tri_tx_chns(flatbuffers::Offset<flatbuffers::Vector<const Triangle *>> tri_tx_chns) {
    fbb_.AddOffset(Face::VT_TRI_TX_CHNS, tri_tx_chns);
  }
  explicit FaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FaceBuilder &operator=(const FaceBuilder &);
  flatbuffers::Offset<Face> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Face>(end);
    fbb_.Required(o, Face::VT_TRI_WS);
    fbb_.Required(o, Face::VT_TRI_MS);
    return o;
  }
};

inline flatbuffers::Offset<Face> CreateFace(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Triangle *tri_ws = 0,
    const Triangle *tri_ms = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Triangle *>> tri_tx_chns = 0) {
  FaceBuilder builder_(_fbb);
  builder_.add_tri_tx_chns(tri_tx_chns);
  builder_.add_tri_ms(tri_ms);
  builder_.add_tri_ws(tri_ws);
  return builder_.Finish();
}

inline flatbuffers::Offset<Face> CreateFaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Triangle *tri_ws = 0,
    const Triangle *tri_ms = 0,
    const std::vector<Triangle> *tri_tx_chns = nullptr) {
  return ARCSim::CreateFace(
      _fbb,
      tri_ws,
      tri_ms,
      tri_tx_chns ? _fbb.CreateVectorOfStructs<Triangle>(*tri_tx_chns) : 0);
}

flatbuffers::Offset<Face> CreateFace(flatbuffers::FlatBufferBuilder &_fbb, const FaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CurveT : public flatbuffers::NativeTable {
  typedef Curve TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.CurveT";
  }
  CurveType type;
  std::string name;
  std::vector<Vec2> control_points;
  EdgeTreatment edge_treatment;
  CurveT()
      : type(CurveType::Polyline),
        edge_treatment(EdgeTreatment::Block) {
  }
};

struct Curve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurveT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Curve";
  }
  enum {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_CONTROL_POINTS = 8,
    VT_EDGE_TREATMENT = 10
  };
  CurveType type() const {
    return static_cast<CurveType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<const Vec2 *> *control_points() const {
    return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_CONTROL_POINTS);
  }
  EdgeTreatment edge_treatment() const {
    return static_cast<EdgeTreatment>(GetField<int8_t>(VT_EDGE_TREATMENT, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_CONTROL_POINTS) &&
           verifier.Verify(control_points()) &&
           VerifyField<int8_t>(verifier, VT_EDGE_TREATMENT) &&
           verifier.EndTable();
  }
  CurveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CurveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Curve> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CurveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CurveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(CurveType type) {
    fbb_.AddElement<int8_t>(Curve::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Curve::VT_NAME, name);
  }
  void add_control_points(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> control_points) {
    fbb_.AddOffset(Curve::VT_CONTROL_POINTS, control_points);
  }
  void add_edge_treatment(EdgeTreatment edge_treatment) {
    fbb_.AddElement<int8_t>(Curve::VT_EDGE_TREATMENT, static_cast<int8_t>(edge_treatment), 1);
  }
  explicit CurveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurveBuilder &operator=(const CurveBuilder &);
  flatbuffers::Offset<Curve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Curve>(end);
    return o;
  }
};

inline flatbuffers::Offset<Curve> CreateCurve(
    flatbuffers::FlatBufferBuilder &_fbb,
    CurveType type = CurveType::Polyline,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> control_points = 0,
    EdgeTreatment edge_treatment = EdgeTreatment::Block) {
  CurveBuilder builder_(_fbb);
  builder_.add_control_points(control_points);
  builder_.add_name(name);
  builder_.add_edge_treatment(edge_treatment);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Curve> CreateCurveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    CurveType type = CurveType::Polyline,
    const char *name = nullptr,
    const std::vector<Vec2> *control_points = nullptr,
    EdgeTreatment edge_treatment = EdgeTreatment::Block) {
  return ARCSim::CreateCurve(
      _fbb,
      type,
      name ? _fbb.CreateString(name) : 0,
      control_points ? _fbb.CreateVectorOfStructs<Vec2>(*control_points) : 0,
      edge_treatment);
}

flatbuffers::Offset<Curve> CreateCurve(flatbuffers::FlatBufferBuilder &_fbb, const CurveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WorldSpaceCoordinatesT : public flatbuffers::NativeTable {
  typedef WorldSpaceCoordinates TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.WorldSpaceCoordinatesT";
  }
  std::vector<Vec3> vertices;
  WorldSpaceCoordinatesT() {
  }
};

struct WorldSpaceCoordinates FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorldSpaceCoordinatesT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.WorldSpaceCoordinates";
  }
  enum {
    VT_VERTICES = 4
  };
  const flatbuffers::Vector<const Vec3 *> *vertices() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_VERTICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           verifier.EndTable();
  }
  WorldSpaceCoordinatesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WorldSpaceCoordinatesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WorldSpaceCoordinates> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WorldSpaceCoordinatesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WorldSpaceCoordinatesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> vertices) {
    fbb_.AddOffset(WorldSpaceCoordinates::VT_VERTICES, vertices);
  }
  explicit WorldSpaceCoordinatesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorldSpaceCoordinatesBuilder &operator=(const WorldSpaceCoordinatesBuilder &);
  flatbuffers::Offset<WorldSpaceCoordinates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorldSpaceCoordinates>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorldSpaceCoordinates> CreateWorldSpaceCoordinates(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> vertices = 0) {
  WorldSpaceCoordinatesBuilder builder_(_fbb);
  builder_.add_vertices(vertices);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorldSpaceCoordinates> CreateWorldSpaceCoordinatesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Vec3> *vertices = nullptr) {
  return ARCSim::CreateWorldSpaceCoordinates(
      _fbb,
      vertices ? _fbb.CreateVectorOfStructs<Vec3>(*vertices) : 0);
}

flatbuffers::Offset<WorldSpaceCoordinates> CreateWorldSpaceCoordinates(flatbuffers::FlatBufferBuilder &_fbb, const WorldSpaceCoordinatesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaterialSpaceCoordinatesT : public flatbuffers::NativeTable {
  typedef MaterialSpaceCoordinates TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.MaterialSpaceCoordinatesT";
  }
  std::vector<Vec2> vertices;
  MaterialSpaceCoordinatesT() {
  }
};

struct MaterialSpaceCoordinates FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialSpaceCoordinatesT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.MaterialSpaceCoordinates";
  }
  enum {
    VT_VERTICES = 4
  };
  const flatbuffers::Vector<const Vec2 *> *vertices() const {
    return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_VERTICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           verifier.EndTable();
  }
  MaterialSpaceCoordinatesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaterialSpaceCoordinatesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaterialSpaceCoordinates> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaterialSpaceCoordinatesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaterialSpaceCoordinatesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> vertices) {
    fbb_.AddOffset(MaterialSpaceCoordinates::VT_VERTICES, vertices);
  }
  explicit MaterialSpaceCoordinatesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialSpaceCoordinatesBuilder &operator=(const MaterialSpaceCoordinatesBuilder &);
  flatbuffers::Offset<MaterialSpaceCoordinates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialSpaceCoordinates>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialSpaceCoordinates> CreateMaterialSpaceCoordinates(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> vertices = 0) {
  MaterialSpaceCoordinatesBuilder builder_(_fbb);
  builder_.add_vertices(vertices);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaterialSpaceCoordinates> CreateMaterialSpaceCoordinatesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Vec2> *vertices = nullptr) {
  return ARCSim::CreateMaterialSpaceCoordinates(
      _fbb,
      vertices ? _fbb.CreateVectorOfStructs<Vec2>(*vertices) : 0);
}

flatbuffers::Offset<MaterialSpaceCoordinates> CreateMaterialSpaceCoordinates(flatbuffers::FlatBufferBuilder &_fbb, const MaterialSpaceCoordinatesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeometryT : public flatbuffers::NativeTable {
  typedef Geometry TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GeometryT";
  }
  std::unique_ptr<WorldSpaceCoordinatesT> vertices_ws;
  std::unique_ptr<MaterialSpaceCoordinatesT> vertices_ms;
  std::vector<std::unique_ptr<MaterialSpaceCoordinatesT>> texture_channels;
  std::vector<std::unique_ptr<FaceT>> faces;
  GeometryT() {
  }
};

struct Geometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Geometry";
  }
  enum {
    VT_VERTICES_WS = 4,
    VT_VERTICES_MS = 6,
    VT_TEXTURE_CHANNELS = 8,
    VT_FACES = 10
  };
  const WorldSpaceCoordinates *vertices_ws() const {
    return GetPointer<const WorldSpaceCoordinates *>(VT_VERTICES_WS);
  }
  const MaterialSpaceCoordinates *vertices_ms() const {
    return GetPointer<const MaterialSpaceCoordinates *>(VT_VERTICES_MS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MaterialSpaceCoordinates>> *texture_channels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MaterialSpaceCoordinates>> *>(VT_TEXTURE_CHANNELS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Face>> *faces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Face>> *>(VT_FACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES_WS) &&
           verifier.VerifyTable(vertices_ws()) &&
           VerifyOffset(verifier, VT_VERTICES_MS) &&
           verifier.VerifyTable(vertices_ms()) &&
           VerifyOffset(verifier, VT_TEXTURE_CHANNELS) &&
           verifier.Verify(texture_channels()) &&
           verifier.VerifyVectorOfTables(texture_channels()) &&
           VerifyOffset(verifier, VT_FACES) &&
           verifier.Verify(faces()) &&
           verifier.VerifyVectorOfTables(faces()) &&
           verifier.EndTable();
  }
  GeometryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeometryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Geometry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeometryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeometryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices_ws(flatbuffers::Offset<WorldSpaceCoordinates> vertices_ws) {
    fbb_.AddOffset(Geometry::VT_VERTICES_WS, vertices_ws);
  }
  void add_vertices_ms(flatbuffers::Offset<MaterialSpaceCoordinates> vertices_ms) {
    fbb_.AddOffset(Geometry::VT_VERTICES_MS, vertices_ms);
  }
  void add_texture_channels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MaterialSpaceCoordinates>>> texture_channels) {
    fbb_.AddOffset(Geometry::VT_TEXTURE_CHANNELS, texture_channels);
  }
  void add_faces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Face>>> faces) {
    fbb_.AddOffset(Geometry::VT_FACES, faces);
  }
  explicit GeometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryBuilder &operator=(const GeometryBuilder &);
  flatbuffers::Offset<Geometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Geometry>(end);
    return o;
  }
};

inline flatbuffers::Offset<Geometry> CreateGeometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<WorldSpaceCoordinates> vertices_ws = 0,
    flatbuffers::Offset<MaterialSpaceCoordinates> vertices_ms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MaterialSpaceCoordinates>>> texture_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Face>>> faces = 0) {
  GeometryBuilder builder_(_fbb);
  builder_.add_faces(faces);
  builder_.add_texture_channels(texture_channels);
  builder_.add_vertices_ms(vertices_ms);
  builder_.add_vertices_ws(vertices_ws);
  return builder_.Finish();
}

inline flatbuffers::Offset<Geometry> CreateGeometryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<WorldSpaceCoordinates> vertices_ws = 0,
    flatbuffers::Offset<MaterialSpaceCoordinates> vertices_ms = 0,
    const std::vector<flatbuffers::Offset<MaterialSpaceCoordinates>> *texture_channels = nullptr,
    const std::vector<flatbuffers::Offset<Face>> *faces = nullptr) {
  return ARCSim::CreateGeometry(
      _fbb,
      vertices_ws,
      vertices_ms,
      texture_channels ? _fbb.CreateVector<flatbuffers::Offset<MaterialSpaceCoordinates>>(*texture_channels) : 0,
      faces ? _fbb.CreateVector<flatbuffers::Offset<Face>>(*faces) : 0);
}

flatbuffers::Offset<Geometry> CreateGeometry(flatbuffers::FlatBufferBuilder &_fbb, const GeometryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FoldT : public flatbuffers::NativeTable {
  typedef Fold TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.FoldT";
  }
  FoldType type;
  uint32_t curve;
  float angle;
  float start_angle;
  float end_angle;
  FoldT()
      : type(FoldType::Simple),
        curve(0),
        angle(0.0f),
        start_angle(0.0f),
        end_angle(0.0f) {
  }
};

struct Fold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FoldT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Fold";
  }
  enum {
    VT_TYPE = 4,
    VT_CURVE = 6,
    VT_ANGLE = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12
  };
  FoldType type() const {
    return static_cast<FoldType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t curve() const {
    return GetField<uint32_t>(VT_CURVE, 0);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_CURVE) &&
           VerifyField<float>(verifier, VT_ANGLE) &&
           VerifyField<float>(verifier, VT_START_ANGLE) &&
           VerifyField<float>(verifier, VT_END_ANGLE) &&
           verifier.EndTable();
  }
  FoldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FoldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Fold> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FoldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(FoldType type) {
    fbb_.AddElement<int8_t>(Fold::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_curve(uint32_t curve) {
    fbb_.AddElement<uint32_t>(Fold::VT_CURVE, curve, 0);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(Fold::VT_ANGLE, angle, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(Fold::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(Fold::VT_END_ANGLE, end_angle, 0.0f);
  }
  explicit FoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FoldBuilder &operator=(const FoldBuilder &);
  flatbuffers::Offset<Fold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fold>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fold> CreateFold(
    flatbuffers::FlatBufferBuilder &_fbb,
    FoldType type = FoldType::Simple,
    uint32_t curve = 0,
    float angle = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f) {
  FoldBuilder builder_(_fbb);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_angle(angle);
  builder_.add_curve(curve);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Fold> CreateFold(flatbuffers::FlatBufferBuilder &_fbb, const FoldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CurveMapT : public flatbuffers::NativeTable {
  typedef CurveMap TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.CurveMapT";
  }
  std::vector<uint32_t> vertices_ms;
  CurveMapT() {
  }
};

struct CurveMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurveMapT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.CurveMap";
  }
  enum {
    VT_VERTICES_MS = 4
  };
  const flatbuffers::Vector<uint32_t> *vertices_ms() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_VERTICES_MS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES_MS) &&
           verifier.Verify(vertices_ms()) &&
           verifier.EndTable();
  }
  CurveMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CurveMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CurveMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CurveMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CurveMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices_ms(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> vertices_ms) {
    fbb_.AddOffset(CurveMap::VT_VERTICES_MS, vertices_ms);
  }
  explicit CurveMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurveMapBuilder &operator=(const CurveMapBuilder &);
  flatbuffers::Offset<CurveMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurveMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurveMap> CreateCurveMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> vertices_ms = 0) {
  CurveMapBuilder builder_(_fbb);
  builder_.add_vertices_ms(vertices_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<CurveMap> CreateCurveMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *vertices_ms = nullptr) {
  return ARCSim::CreateCurveMap(
      _fbb,
      vertices_ms ? _fbb.CreateVector<uint32_t>(*vertices_ms) : 0);
}

flatbuffers::Offset<CurveMap> CreateCurveMap(flatbuffers::FlatBufferBuilder &_fbb, const CurveMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PieceMapT : public flatbuffers::NativeTable {
  typedef PieceMap TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.PieceMapT";
  }
  std::vector<uint32_t> vertices_ms;
  std::vector<std::unique_ptr<CurveMapT>> curve_maps;
  PieceMapT() {
  }
};

struct PieceMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PieceMapT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.PieceMap";
  }
  enum {
    VT_VERTICES_MS = 4,
    VT_CURVE_MAPS = 6
  };
  const flatbuffers::Vector<uint32_t> *vertices_ms() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_VERTICES_MS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CurveMap>> *curve_maps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CurveMap>> *>(VT_CURVE_MAPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES_MS) &&
           verifier.Verify(vertices_ms()) &&
           VerifyOffset(verifier, VT_CURVE_MAPS) &&
           verifier.Verify(curve_maps()) &&
           verifier.VerifyVectorOfTables(curve_maps()) &&
           verifier.EndTable();
  }
  PieceMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PieceMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PieceMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PieceMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PieceMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices_ms(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> vertices_ms) {
    fbb_.AddOffset(PieceMap::VT_VERTICES_MS, vertices_ms);
  }
  void add_curve_maps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CurveMap>>> curve_maps) {
    fbb_.AddOffset(PieceMap::VT_CURVE_MAPS, curve_maps);
  }
  explicit PieceMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PieceMapBuilder &operator=(const PieceMapBuilder &);
  flatbuffers::Offset<PieceMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PieceMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<PieceMap> CreatePieceMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> vertices_ms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CurveMap>>> curve_maps = 0) {
  PieceMapBuilder builder_(_fbb);
  builder_.add_curve_maps(curve_maps);
  builder_.add_vertices_ms(vertices_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<PieceMap> CreatePieceMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *vertices_ms = nullptr,
    const std::vector<flatbuffers::Offset<CurveMap>> *curve_maps = nullptr) {
  return ARCSim::CreatePieceMap(
      _fbb,
      vertices_ms ? _fbb.CreateVector<uint32_t>(*vertices_ms) : 0,
      curve_maps ? _fbb.CreateVector<flatbuffers::Offset<CurveMap>>(*curve_maps) : 0);
}

flatbuffers::Offset<PieceMap> CreatePieceMap(flatbuffers::FlatBufferBuilder &_fbb, const PieceMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PieceT : public flatbuffers::NativeTable {
  typedef Piece TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.PieceT";
  }
  std::string name;
  std::vector<std::unique_ptr<CurveT>> curves;
  std::vector<uint32_t> boundary;
  std::vector<std::unique_ptr<FoldT>> folds;
  uint32_t fabric;
  float extrusion_thickness;
  PieceT()
      : fabric(0),
        extrusion_thickness(0.0f) {
  }
};

struct Piece FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PieceT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Piece";
  }
  enum {
    VT_NAME = 4,
    VT_CURVES = 6,
    VT_BOUNDARY = 8,
    VT_FOLDS = 10,
    VT_FABRIC = 12,
    VT_EXTRUSION_THICKNESS = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Curve>> *curves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Curve>> *>(VT_CURVES);
  }
  const flatbuffers::Vector<uint32_t> *boundary() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_BOUNDARY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fold>> *folds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fold>> *>(VT_FOLDS);
  }
  uint32_t fabric() const {
    return GetField<uint32_t>(VT_FABRIC, 0);
  }
  float extrusion_thickness() const {
    return GetField<float>(VT_EXTRUSION_THICKNESS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_CURVES) &&
           verifier.Verify(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           VerifyOffset(verifier, VT_BOUNDARY) &&
           verifier.Verify(boundary()) &&
           VerifyOffset(verifier, VT_FOLDS) &&
           verifier.Verify(folds()) &&
           verifier.VerifyVectorOfTables(folds()) &&
           VerifyField<uint32_t>(verifier, VT_FABRIC) &&
           VerifyField<float>(verifier, VT_EXTRUSION_THICKNESS) &&
           verifier.EndTable();
  }
  PieceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PieceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Piece> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PieceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PieceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Piece::VT_NAME, name);
  }
  void add_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Curve>>> curves) {
    fbb_.AddOffset(Piece::VT_CURVES, curves);
  }
  void add_boundary(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> boundary) {
    fbb_.AddOffset(Piece::VT_BOUNDARY, boundary);
  }
  void add_folds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fold>>> folds) {
    fbb_.AddOffset(Piece::VT_FOLDS, folds);
  }
  void add_fabric(uint32_t fabric) {
    fbb_.AddElement<uint32_t>(Piece::VT_FABRIC, fabric, 0);
  }
  void add_extrusion_thickness(float extrusion_thickness) {
    fbb_.AddElement<float>(Piece::VT_EXTRUSION_THICKNESS, extrusion_thickness, 0.0f);
  }
  explicit PieceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PieceBuilder &operator=(const PieceBuilder &);
  flatbuffers::Offset<Piece> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Piece>(end);
    return o;
  }
};

inline flatbuffers::Offset<Piece> CreatePiece(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Curve>>> curves = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> boundary = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fold>>> folds = 0,
    uint32_t fabric = 0,
    float extrusion_thickness = 0.0f) {
  PieceBuilder builder_(_fbb);
  builder_.add_extrusion_thickness(extrusion_thickness);
  builder_.add_fabric(fabric);
  builder_.add_folds(folds);
  builder_.add_boundary(boundary);
  builder_.add_curves(curves);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Piece> CreatePieceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<Curve>> *curves = nullptr,
    const std::vector<uint32_t> *boundary = nullptr,
    const std::vector<flatbuffers::Offset<Fold>> *folds = nullptr,
    uint32_t fabric = 0,
    float extrusion_thickness = 0.0f) {
  return ARCSim::CreatePiece(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      curves ? _fbb.CreateVector<flatbuffers::Offset<Curve>>(*curves) : 0,
      boundary ? _fbb.CreateVector<uint32_t>(*boundary) : 0,
      folds ? _fbb.CreateVector<flatbuffers::Offset<Fold>>(*folds) : 0,
      fabric,
      extrusion_thickness);
}

flatbuffers::Offset<Piece> CreatePiece(flatbuffers::FlatBufferBuilder &_fbb, const PieceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SeamT : public flatbuffers::NativeTable {
  typedef Seam TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.SeamT";
  }
  uint32_t piece_a;
  uint32_t curve_a;
  uint32_t piece_b;
  uint32_t curve_b;
  bool reversed;
  float seam_angle;
  SeamT()
      : piece_a(0),
        curve_a(0),
        piece_b(0),
        curve_b(0),
        reversed(false),
        seam_angle(0.0f) {
  }
};

struct Seam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SeamT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Seam";
  }
  enum {
    VT_PIECE_A = 4,
    VT_CURVE_A = 6,
    VT_PIECE_B = 8,
    VT_CURVE_B = 10,
    VT_REVERSED = 12,
    VT_SEAM_ANGLE = 14
  };
  uint32_t piece_a() const {
    return GetField<uint32_t>(VT_PIECE_A, 0);
  }
  uint32_t curve_a() const {
    return GetField<uint32_t>(VT_CURVE_A, 0);
  }
  uint32_t piece_b() const {
    return GetField<uint32_t>(VT_PIECE_B, 0);
  }
  uint32_t curve_b() const {
    return GetField<uint32_t>(VT_CURVE_B, 0);
  }
  bool reversed() const {
    return GetField<uint8_t>(VT_REVERSED, 0) != 0;
  }
  float seam_angle() const {
    return GetField<float>(VT_SEAM_ANGLE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PIECE_A) &&
           VerifyField<uint32_t>(verifier, VT_CURVE_A) &&
           VerifyField<uint32_t>(verifier, VT_PIECE_B) &&
           VerifyField<uint32_t>(verifier, VT_CURVE_B) &&
           VerifyField<uint8_t>(verifier, VT_REVERSED) &&
           VerifyField<float>(verifier, VT_SEAM_ANGLE) &&
           verifier.EndTable();
  }
  SeamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SeamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Seam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SeamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_piece_a(uint32_t piece_a) {
    fbb_.AddElement<uint32_t>(Seam::VT_PIECE_A, piece_a, 0);
  }
  void add_curve_a(uint32_t curve_a) {
    fbb_.AddElement<uint32_t>(Seam::VT_CURVE_A, curve_a, 0);
  }
  void add_piece_b(uint32_t piece_b) {
    fbb_.AddElement<uint32_t>(Seam::VT_PIECE_B, piece_b, 0);
  }
  void add_curve_b(uint32_t curve_b) {
    fbb_.AddElement<uint32_t>(Seam::VT_CURVE_B, curve_b, 0);
  }
  void add_reversed(bool reversed) {
    fbb_.AddElement<uint8_t>(Seam::VT_REVERSED, static_cast<uint8_t>(reversed), 0);
  }
  void add_seam_angle(float seam_angle) {
    fbb_.AddElement<float>(Seam::VT_SEAM_ANGLE, seam_angle, 0.0f);
  }
  explicit SeamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeamBuilder &operator=(const SeamBuilder &);
  flatbuffers::Offset<Seam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Seam>(end);
    return o;
  }
};

inline flatbuffers::Offset<Seam> CreateSeam(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t piece_a = 0,
    uint32_t curve_a = 0,
    uint32_t piece_b = 0,
    uint32_t curve_b = 0,
    bool reversed = false,
    float seam_angle = 0.0f) {
  SeamBuilder builder_(_fbb);
  builder_.add_seam_angle(seam_angle);
  builder_.add_curve_b(curve_b);
  builder_.add_piece_b(piece_b);
  builder_.add_curve_a(curve_a);
  builder_.add_piece_a(piece_a);
  builder_.add_reversed(reversed);
  return builder_.Finish();
}

flatbuffers::Offset<Seam> CreateSeam(flatbuffers::FlatBufferBuilder &_fbb, const SeamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AvametricV1FabricT : public flatbuffers::NativeTable {
  typedef AvametricV1Fabric TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AvametricV1FabricT";
  }
  float density;
  AvametricBaseMaterial basetype;
  float stretch_c11;
  float stretch_c12;
  float stretch_c22;
  float stretch_c33;
  float bending;
  AvametricV1FabricT()
      : density(1.0f),
        basetype(AvametricBaseMaterial::GrayInterlock),
        stretch_c11(1.0f),
        stretch_c12(1.0f),
        stretch_c22(1.0f),
        stretch_c33(1.0f),
        bending(1.0f) {
  }
};

struct AvametricV1Fabric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AvametricV1FabricT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AvametricV1Fabric";
  }
  enum {
    VT_DENSITY = 4,
    VT_BASETYPE = 6,
    VT_STRETCH_C11 = 8,
    VT_STRETCH_C12 = 10,
    VT_STRETCH_C22 = 12,
    VT_STRETCH_C33 = 14,
    VT_BENDING = 16
  };
  float density() const {
    return GetField<float>(VT_DENSITY, 1.0f);
  }
  AvametricBaseMaterial basetype() const {
    return static_cast<AvametricBaseMaterial>(GetField<int8_t>(VT_BASETYPE, 0));
  }
  float stretch_c11() const {
    return GetField<float>(VT_STRETCH_C11, 1.0f);
  }
  float stretch_c12() const {
    return GetField<float>(VT_STRETCH_C12, 1.0f);
  }
  float stretch_c22() const {
    return GetField<float>(VT_STRETCH_C22, 1.0f);
  }
  float stretch_c33() const {
    return GetField<float>(VT_STRETCH_C33, 1.0f);
  }
  float bending() const {
    return GetField<float>(VT_BENDING, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DENSITY) &&
           VerifyField<int8_t>(verifier, VT_BASETYPE) &&
           VerifyField<float>(verifier, VT_STRETCH_C11) &&
           VerifyField<float>(verifier, VT_STRETCH_C12) &&
           VerifyField<float>(verifier, VT_STRETCH_C22) &&
           VerifyField<float>(verifier, VT_STRETCH_C33) &&
           VerifyField<float>(verifier, VT_BENDING) &&
           verifier.EndTable();
  }
  AvametricV1FabricT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AvametricV1FabricT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AvametricV1Fabric> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvametricV1FabricT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AvametricV1FabricBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_density(float density) {
    fbb_.AddElement<float>(AvametricV1Fabric::VT_DENSITY, density, 1.0f);
  }
  void add_basetype(AvametricBaseMaterial basetype) {
    fbb_.AddElement<int8_t>(AvametricV1Fabric::VT_BASETYPE, static_cast<int8_t>(basetype), 0);
  }
  void add_stretch_c11(float stretch_c11) {
    fbb_.AddElement<float>(AvametricV1Fabric::VT_STRETCH_C11, stretch_c11, 1.0f);
  }
  void add_stretch_c12(float stretch_c12) {
    fbb_.AddElement<float>(AvametricV1Fabric::VT_STRETCH_C12, stretch_c12, 1.0f);
  }
  void add_stretch_c22(float stretch_c22) {
    fbb_.AddElement<float>(AvametricV1Fabric::VT_STRETCH_C22, stretch_c22, 1.0f);
  }
  void add_stretch_c33(float stretch_c33) {
    fbb_.AddElement<float>(AvametricV1Fabric::VT_STRETCH_C33, stretch_c33, 1.0f);
  }
  void add_bending(float bending) {
    fbb_.AddElement<float>(AvametricV1Fabric::VT_BENDING, bending, 1.0f);
  }
  explicit AvametricV1FabricBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AvametricV1FabricBuilder &operator=(const AvametricV1FabricBuilder &);
  flatbuffers::Offset<AvametricV1Fabric> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AvametricV1Fabric>(end);
    return o;
  }
};

inline flatbuffers::Offset<AvametricV1Fabric> CreateAvametricV1Fabric(
    flatbuffers::FlatBufferBuilder &_fbb,
    float density = 1.0f,
    AvametricBaseMaterial basetype = AvametricBaseMaterial::GrayInterlock,
    float stretch_c11 = 1.0f,
    float stretch_c12 = 1.0f,
    float stretch_c22 = 1.0f,
    float stretch_c33 = 1.0f,
    float bending = 1.0f) {
  AvametricV1FabricBuilder builder_(_fbb);
  builder_.add_bending(bending);
  builder_.add_stretch_c33(stretch_c33);
  builder_.add_stretch_c22(stretch_c22);
  builder_.add_stretch_c12(stretch_c12);
  builder_.add_stretch_c11(stretch_c11);
  builder_.add_density(density);
  builder_.add_basetype(basetype);
  return builder_.Finish();
}

flatbuffers::Offset<AvametricV1Fabric> CreateAvametricV1Fabric(flatbuffers::FlatBufferBuilder &_fbb, const AvametricV1FabricT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GerberFabricT : public flatbuffers::NativeTable {
  typedef GerberFabric TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GerberFabricT";
  }
  float density;
  float stretch_x;
  float stretch_y;
  float stretch_bias;
  float bending_x;
  float bending_y;
  float bending_bias;
  GerberFabricT()
      : density(1.0f),
        stretch_x(1.0f),
        stretch_y(1.0f),
        stretch_bias(1.0f),
        bending_x(1.0f),
        bending_y(1.0f),
        bending_bias(1.0f) {
  }
};

struct GerberFabric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GerberFabricT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GerberFabric";
  }
  enum {
    VT_DENSITY = 4,
    VT_STRETCH_X = 6,
    VT_STRETCH_Y = 8,
    VT_STRETCH_BIAS = 10,
    VT_BENDING_X = 12,
    VT_BENDING_Y = 14,
    VT_BENDING_BIAS = 16
  };
  float density() const {
    return GetField<float>(VT_DENSITY, 1.0f);
  }
  float stretch_x() const {
    return GetField<float>(VT_STRETCH_X, 1.0f);
  }
  float stretch_y() const {
    return GetField<float>(VT_STRETCH_Y, 1.0f);
  }
  float stretch_bias() const {
    return GetField<float>(VT_STRETCH_BIAS, 1.0f);
  }
  float bending_x() const {
    return GetField<float>(VT_BENDING_X, 1.0f);
  }
  float bending_y() const {
    return GetField<float>(VT_BENDING_Y, 1.0f);
  }
  float bending_bias() const {
    return GetField<float>(VT_BENDING_BIAS, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DENSITY) &&
           VerifyField<float>(verifier, VT_STRETCH_X) &&
           VerifyField<float>(verifier, VT_STRETCH_Y) &&
           VerifyField<float>(verifier, VT_STRETCH_BIAS) &&
           VerifyField<float>(verifier, VT_BENDING_X) &&
           VerifyField<float>(verifier, VT_BENDING_Y) &&
           VerifyField<float>(verifier, VT_BENDING_BIAS) &&
           verifier.EndTable();
  }
  GerberFabricT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GerberFabricT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GerberFabric> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GerberFabricT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GerberFabricBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_density(float density) {
    fbb_.AddElement<float>(GerberFabric::VT_DENSITY, density, 1.0f);
  }
  void add_stretch_x(float stretch_x) {
    fbb_.AddElement<float>(GerberFabric::VT_STRETCH_X, stretch_x, 1.0f);
  }
  void add_stretch_y(float stretch_y) {
    fbb_.AddElement<float>(GerberFabric::VT_STRETCH_Y, stretch_y, 1.0f);
  }
  void add_stretch_bias(float stretch_bias) {
    fbb_.AddElement<float>(GerberFabric::VT_STRETCH_BIAS, stretch_bias, 1.0f);
  }
  void add_bending_x(float bending_x) {
    fbb_.AddElement<float>(GerberFabric::VT_BENDING_X, bending_x, 1.0f);
  }
  void add_bending_y(float bending_y) {
    fbb_.AddElement<float>(GerberFabric::VT_BENDING_Y, bending_y, 1.0f);
  }
  void add_bending_bias(float bending_bias) {
    fbb_.AddElement<float>(GerberFabric::VT_BENDING_BIAS, bending_bias, 1.0f);
  }
  explicit GerberFabricBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GerberFabricBuilder &operator=(const GerberFabricBuilder &);
  flatbuffers::Offset<GerberFabric> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GerberFabric>(end);
    return o;
  }
};

inline flatbuffers::Offset<GerberFabric> CreateGerberFabric(
    flatbuffers::FlatBufferBuilder &_fbb,
    float density = 1.0f,
    float stretch_x = 1.0f,
    float stretch_y = 1.0f,
    float stretch_bias = 1.0f,
    float bending_x = 1.0f,
    float bending_y = 1.0f,
    float bending_bias = 1.0f) {
  GerberFabricBuilder builder_(_fbb);
  builder_.add_bending_bias(bending_bias);
  builder_.add_bending_y(bending_y);
  builder_.add_bending_x(bending_x);
  builder_.add_stretch_bias(stretch_bias);
  builder_.add_stretch_y(stretch_y);
  builder_.add_stretch_x(stretch_x);
  builder_.add_density(density);
  return builder_.Finish();
}

flatbuffers::Offset<GerberFabric> CreateGerberFabric(flatbuffers::FlatBufferBuilder &_fbb, const GerberFabricT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SimpleAnisotropicFabricT : public flatbuffers::NativeTable {
  typedef SimpleAnisotropicFabric TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.SimpleAnisotropicFabricT";
  }
  float density;
  float youngs_modulus_x;
  float youngs_modulus_y;
  float poissons_ratio;
  float shear_modulus;
  float bending_x;
  float bending_y;
  float bending_bias;
  SimpleAnisotropicFabricT()
      : density(1.0f),
        youngs_modulus_x(1.0f),
        youngs_modulus_y(1.0f),
        poissons_ratio(0.45f),
        shear_modulus(1.0f),
        bending_x(1.0f),
        bending_y(1.0f),
        bending_bias(1.0f) {
  }
};

struct SimpleAnisotropicFabric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimpleAnisotropicFabricT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.SimpleAnisotropicFabric";
  }
  enum {
    VT_DENSITY = 4,
    VT_YOUNGS_MODULUS_X = 6,
    VT_YOUNGS_MODULUS_Y = 8,
    VT_POISSONS_RATIO = 10,
    VT_SHEAR_MODULUS = 12,
    VT_BENDING_X = 14,
    VT_BENDING_Y = 16,
    VT_BENDING_BIAS = 18
  };
  float density() const {
    return GetField<float>(VT_DENSITY, 1.0f);
  }
  float youngs_modulus_x() const {
    return GetField<float>(VT_YOUNGS_MODULUS_X, 1.0f);
  }
  float youngs_modulus_y() const {
    return GetField<float>(VT_YOUNGS_MODULUS_Y, 1.0f);
  }
  float poissons_ratio() const {
    return GetField<float>(VT_POISSONS_RATIO, 0.45f);
  }
  float shear_modulus() const {
    return GetField<float>(VT_SHEAR_MODULUS, 1.0f);
  }
  float bending_x() const {
    return GetField<float>(VT_BENDING_X, 1.0f);
  }
  float bending_y() const {
    return GetField<float>(VT_BENDING_Y, 1.0f);
  }
  float bending_bias() const {
    return GetField<float>(VT_BENDING_BIAS, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DENSITY) &&
           VerifyField<float>(verifier, VT_YOUNGS_MODULUS_X) &&
           VerifyField<float>(verifier, VT_YOUNGS_MODULUS_Y) &&
           VerifyField<float>(verifier, VT_POISSONS_RATIO) &&
           VerifyField<float>(verifier, VT_SHEAR_MODULUS) &&
           VerifyField<float>(verifier, VT_BENDING_X) &&
           VerifyField<float>(verifier, VT_BENDING_Y) &&
           VerifyField<float>(verifier, VT_BENDING_BIAS) &&
           verifier.EndTable();
  }
  SimpleAnisotropicFabricT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SimpleAnisotropicFabricT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SimpleAnisotropicFabric> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimpleAnisotropicFabricT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SimpleAnisotropicFabricBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_density(float density) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_DENSITY, density, 1.0f);
  }
  void add_youngs_modulus_x(float youngs_modulus_x) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_YOUNGS_MODULUS_X, youngs_modulus_x, 1.0f);
  }
  void add_youngs_modulus_y(float youngs_modulus_y) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_YOUNGS_MODULUS_Y, youngs_modulus_y, 1.0f);
  }
  void add_poissons_ratio(float poissons_ratio) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_POISSONS_RATIO, poissons_ratio, 0.45f);
  }
  void add_shear_modulus(float shear_modulus) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_SHEAR_MODULUS, shear_modulus, 1.0f);
  }
  void add_bending_x(float bending_x) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_BENDING_X, bending_x, 1.0f);
  }
  void add_bending_y(float bending_y) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_BENDING_Y, bending_y, 1.0f);
  }
  void add_bending_bias(float bending_bias) {
    fbb_.AddElement<float>(SimpleAnisotropicFabric::VT_BENDING_BIAS, bending_bias, 1.0f);
  }
  explicit SimpleAnisotropicFabricBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimpleAnisotropicFabricBuilder &operator=(const SimpleAnisotropicFabricBuilder &);
  flatbuffers::Offset<SimpleAnisotropicFabric> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimpleAnisotropicFabric>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimpleAnisotropicFabric> CreateSimpleAnisotropicFabric(
    flatbuffers::FlatBufferBuilder &_fbb,
    float density = 1.0f,
    float youngs_modulus_x = 1.0f,
    float youngs_modulus_y = 1.0f,
    float poissons_ratio = 0.45f,
    float shear_modulus = 1.0f,
    float bending_x = 1.0f,
    float bending_y = 1.0f,
    float bending_bias = 1.0f) {
  SimpleAnisotropicFabricBuilder builder_(_fbb);
  builder_.add_bending_bias(bending_bias);
  builder_.add_bending_y(bending_y);
  builder_.add_bending_x(bending_x);
  builder_.add_shear_modulus(shear_modulus);
  builder_.add_poissons_ratio(poissons_ratio);
  builder_.add_youngs_modulus_y(youngs_modulus_y);
  builder_.add_youngs_modulus_x(youngs_modulus_x);
  builder_.add_density(density);
  return builder_.Finish();
}

flatbuffers::Offset<SimpleAnisotropicFabric> CreateSimpleAnisotropicFabric(flatbuffers::FlatBufferBuilder &_fbb, const SimpleAnisotropicFabricT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FabricT : public flatbuffers::NativeTable {
  typedef Fabric TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.FabricT";
  }
  FabricType type;
  std::unique_ptr<AvametricV1FabricT> avametric_v1_props;
  std::unique_ptr<GerberFabricT> gerber_props;
  std::unique_ptr<SimpleAnisotropicFabricT> simple_anisotropic_props;
  FabricT()
      : type(FabricType::AvametricV1) {
  }
};

struct Fabric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FabricT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Fabric";
  }
  enum {
    VT_TYPE = 4,
    VT_AVAMETRIC_V1_PROPS = 6,
    VT_GERBER_PROPS = 8,
    VT_SIMPLE_ANISOTROPIC_PROPS = 10
  };
  FabricType type() const {
    return static_cast<FabricType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const AvametricV1Fabric *avametric_v1_props() const {
    return GetPointer<const AvametricV1Fabric *>(VT_AVAMETRIC_V1_PROPS);
  }
  const GerberFabric *gerber_props() const {
    return GetPointer<const GerberFabric *>(VT_GERBER_PROPS);
  }
  const SimpleAnisotropicFabric *simple_anisotropic_props() const {
    return GetPointer<const SimpleAnisotropicFabric *>(VT_SIMPLE_ANISOTROPIC_PROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_AVAMETRIC_V1_PROPS) &&
           verifier.VerifyTable(avametric_v1_props()) &&
           VerifyOffset(verifier, VT_GERBER_PROPS) &&
           verifier.VerifyTable(gerber_props()) &&
           VerifyOffset(verifier, VT_SIMPLE_ANISOTROPIC_PROPS) &&
           verifier.VerifyTable(simple_anisotropic_props()) &&
           verifier.EndTable();
  }
  FabricT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FabricT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Fabric> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FabricT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FabricBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(FabricType type) {
    fbb_.AddElement<int8_t>(Fabric::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_avametric_v1_props(flatbuffers::Offset<AvametricV1Fabric> avametric_v1_props) {
    fbb_.AddOffset(Fabric::VT_AVAMETRIC_V1_PROPS, avametric_v1_props);
  }
  void add_gerber_props(flatbuffers::Offset<GerberFabric> gerber_props) {
    fbb_.AddOffset(Fabric::VT_GERBER_PROPS, gerber_props);
  }
  void add_simple_anisotropic_props(flatbuffers::Offset<SimpleAnisotropicFabric> simple_anisotropic_props) {
    fbb_.AddOffset(Fabric::VT_SIMPLE_ANISOTROPIC_PROPS, simple_anisotropic_props);
  }
  explicit FabricBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FabricBuilder &operator=(const FabricBuilder &);
  flatbuffers::Offset<Fabric> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fabric>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fabric> CreateFabric(
    flatbuffers::FlatBufferBuilder &_fbb,
    FabricType type = FabricType::AvametricV1,
    flatbuffers::Offset<AvametricV1Fabric> avametric_v1_props = 0,
    flatbuffers::Offset<GerberFabric> gerber_props = 0,
    flatbuffers::Offset<SimpleAnisotropicFabric> simple_anisotropic_props = 0) {
  FabricBuilder builder_(_fbb);
  builder_.add_simple_anisotropic_props(simple_anisotropic_props);
  builder_.add_gerber_props(gerber_props);
  builder_.add_avametric_v1_props(avametric_v1_props);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Fabric> CreateFabric(flatbuffers::FlatBufferBuilder &_fbb, const FabricT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GarmentFrameT : public flatbuffers::NativeTable {
  typedef GarmentFrame TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GarmentFrameT";
  }
  std::unique_ptr<GeometryT> geometry;
  std::vector<std::unique_ptr<GeometryDataVertexT>> vertex_data;
  std::vector<std::unique_ptr<GeometryDataFaceT>> face_data;
  std::vector<std::unique_ptr<PieceMapT>> piece_maps;
  uint32_t frame;
  uint32_t subframe;
  float timestamp;
  GarmentFrameT()
      : frame(0),
        subframe(0),
        timestamp(0.0f) {
  }
};

struct GarmentFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GarmentFrameT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GarmentFrame";
  }
  enum {
    VT_GEOMETRY = 4,
    VT_VERTEX_DATA = 6,
    VT_FACE_DATA = 8,
    VT_PIECE_MAPS = 10,
    VT_FRAME = 12,
    VT_SUBFRAME = 14,
    VT_TIMESTAMP = 16
  };
  const Geometry *geometry() const {
    return GetPointer<const Geometry *>(VT_GEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GeometryDataVertex>> *vertex_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GeometryDataVertex>> *>(VT_VERTEX_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GeometryDataFace>> *face_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GeometryDataFace>> *>(VT_FACE_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PieceMap>> *piece_maps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PieceMap>> *>(VT_PIECE_MAPS);
  }
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint32_t subframe() const {
    return GetField<uint32_t>(VT_SUBFRAME, 0);
  }
  float timestamp() const {
    return GetField<float>(VT_TIMESTAMP, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyTable(geometry()) &&
           VerifyOffset(verifier, VT_VERTEX_DATA) &&
           verifier.Verify(vertex_data()) &&
           verifier.VerifyVectorOfTables(vertex_data()) &&
           VerifyOffset(verifier, VT_FACE_DATA) &&
           verifier.Verify(face_data()) &&
           verifier.VerifyVectorOfTables(face_data()) &&
           VerifyOffset(verifier, VT_PIECE_MAPS) &&
           verifier.Verify(piece_maps()) &&
           verifier.VerifyVectorOfTables(piece_maps()) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint32_t>(verifier, VT_SUBFRAME) &&
           VerifyField<float>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
  GarmentFrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GarmentFrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GarmentFrame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GarmentFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GarmentFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geometry(flatbuffers::Offset<Geometry> geometry) {
    fbb_.AddOffset(GarmentFrame::VT_GEOMETRY, geometry);
  }
  void add_vertex_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GeometryDataVertex>>> vertex_data) {
    fbb_.AddOffset(GarmentFrame::VT_VERTEX_DATA, vertex_data);
  }
  void add_face_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GeometryDataFace>>> face_data) {
    fbb_.AddOffset(GarmentFrame::VT_FACE_DATA, face_data);
  }
  void add_piece_maps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PieceMap>>> piece_maps) {
    fbb_.AddOffset(GarmentFrame::VT_PIECE_MAPS, piece_maps);
  }
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(GarmentFrame::VT_FRAME, frame, 0);
  }
  void add_subframe(uint32_t subframe) {
    fbb_.AddElement<uint32_t>(GarmentFrame::VT_SUBFRAME, subframe, 0);
  }
  void add_timestamp(float timestamp) {
    fbb_.AddElement<float>(GarmentFrame::VT_TIMESTAMP, timestamp, 0.0f);
  }
  explicit GarmentFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GarmentFrameBuilder &operator=(const GarmentFrameBuilder &);
  flatbuffers::Offset<GarmentFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GarmentFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<GarmentFrame> CreateGarmentFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Geometry> geometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GeometryDataVertex>>> vertex_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GeometryDataFace>>> face_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PieceMap>>> piece_maps = 0,
    uint32_t frame = 0,
    uint32_t subframe = 0,
    float timestamp = 0.0f) {
  GarmentFrameBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_subframe(subframe);
  builder_.add_frame(frame);
  builder_.add_piece_maps(piece_maps);
  builder_.add_face_data(face_data);
  builder_.add_vertex_data(vertex_data);
  builder_.add_geometry(geometry);
  return builder_.Finish();
}

inline flatbuffers::Offset<GarmentFrame> CreateGarmentFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Geometry> geometry = 0,
    const std::vector<flatbuffers::Offset<GeometryDataVertex>> *vertex_data = nullptr,
    const std::vector<flatbuffers::Offset<GeometryDataFace>> *face_data = nullptr,
    const std::vector<flatbuffers::Offset<PieceMap>> *piece_maps = nullptr,
    uint32_t frame = 0,
    uint32_t subframe = 0,
    float timestamp = 0.0f) {
  return ARCSim::CreateGarmentFrame(
      _fbb,
      geometry,
      vertex_data ? _fbb.CreateVector<flatbuffers::Offset<GeometryDataVertex>>(*vertex_data) : 0,
      face_data ? _fbb.CreateVector<flatbuffers::Offset<GeometryDataFace>>(*face_data) : 0,
      piece_maps ? _fbb.CreateVector<flatbuffers::Offset<PieceMap>>(*piece_maps) : 0,
      frame,
      subframe,
      timestamp);
}

flatbuffers::Offset<GarmentFrame> CreateGarmentFrame(flatbuffers::FlatBufferBuilder &_fbb, const GarmentFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GarmentT : public flatbuffers::NativeTable {
  typedef Garment TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.GarmentT";
  }
  std::string name;
  std::unique_ptr<GarmentFrameT> initial_geometry;
  std::vector<std::unique_ptr<GarmentFrameT>> frames;
  std::vector<std::unique_ptr<PieceT>> pieces;
  std::vector<std::unique_ptr<SeamT>> seams;
  std::vector<std::unique_ptr<FabricT>> fabrics;
  GarmentT() {
  }
};

struct Garment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GarmentT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Garment";
  }
  enum {
    VT_NAME = 4,
    VT_INITIAL_GEOMETRY = 6,
    VT_FRAMES = 8,
    VT_PIECES = 10,
    VT_SEAMS = 12,
    VT_FABRICS = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GarmentFrame *initial_geometry() const {
    return GetPointer<const GarmentFrame *>(VT_INITIAL_GEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GarmentFrame>> *frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GarmentFrame>> *>(VT_FRAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Piece>> *pieces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Piece>> *>(VT_PIECES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Seam>> *seams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Seam>> *>(VT_SEAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fabric>> *fabrics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fabric>> *>(VT_FABRICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_INITIAL_GEOMETRY) &&
           verifier.VerifyTable(initial_geometry()) &&
           VerifyOffset(verifier, VT_FRAMES) &&
           verifier.Verify(frames()) &&
           verifier.VerifyVectorOfTables(frames()) &&
           VerifyOffset(verifier, VT_PIECES) &&
           verifier.Verify(pieces()) &&
           verifier.VerifyVectorOfTables(pieces()) &&
           VerifyOffset(verifier, VT_SEAMS) &&
           verifier.Verify(seams()) &&
           verifier.VerifyVectorOfTables(seams()) &&
           VerifyOffset(verifier, VT_FABRICS) &&
           verifier.Verify(fabrics()) &&
           verifier.VerifyVectorOfTables(fabrics()) &&
           verifier.EndTable();
  }
  GarmentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GarmentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Garment> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GarmentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GarmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Garment::VT_NAME, name);
  }
  void add_initial_geometry(flatbuffers::Offset<GarmentFrame> initial_geometry) {
    fbb_.AddOffset(Garment::VT_INITIAL_GEOMETRY, initial_geometry);
  }
  void add_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GarmentFrame>>> frames) {
    fbb_.AddOffset(Garment::VT_FRAMES, frames);
  }
  void add_pieces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Piece>>> pieces) {
    fbb_.AddOffset(Garment::VT_PIECES, pieces);
  }
  void add_seams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Seam>>> seams) {
    fbb_.AddOffset(Garment::VT_SEAMS, seams);
  }
  void add_fabrics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fabric>>> fabrics) {
    fbb_.AddOffset(Garment::VT_FABRICS, fabrics);
  }
  explicit GarmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GarmentBuilder &operator=(const GarmentBuilder &);
  flatbuffers::Offset<Garment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Garment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Garment> CreateGarment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<GarmentFrame> initial_geometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GarmentFrame>>> frames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Piece>>> pieces = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Seam>>> seams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fabric>>> fabrics = 0) {
  GarmentBuilder builder_(_fbb);
  builder_.add_fabrics(fabrics);
  builder_.add_seams(seams);
  builder_.add_pieces(pieces);
  builder_.add_frames(frames);
  builder_.add_initial_geometry(initial_geometry);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Garment> CreateGarmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<GarmentFrame> initial_geometry = 0,
    const std::vector<flatbuffers::Offset<GarmentFrame>> *frames = nullptr,
    const std::vector<flatbuffers::Offset<Piece>> *pieces = nullptr,
    const std::vector<flatbuffers::Offset<Seam>> *seams = nullptr,
    const std::vector<flatbuffers::Offset<Fabric>> *fabrics = nullptr) {
  return ARCSim::CreateGarment(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      initial_geometry,
      frames ? _fbb.CreateVector<flatbuffers::Offset<GarmentFrame>>(*frames) : 0,
      pieces ? _fbb.CreateVector<flatbuffers::Offset<Piece>>(*pieces) : 0,
      seams ? _fbb.CreateVector<flatbuffers::Offset<Seam>>(*seams) : 0,
      fabrics ? _fbb.CreateVector<flatbuffers::Offset<Fabric>>(*fabrics) : 0);
}

flatbuffers::Offset<Garment> CreateGarment(flatbuffers::FlatBufferBuilder &_fbb, const GarmentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SdfT : public flatbuffers::NativeTable {
  typedef Sdf TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.SdfT";
  }
  std::vector<uint8_t> data;
  float dx;
  float innerband;
  float outerband;
  SdfT()
      : dx(0.0f),
        innerband(0.0f),
        outerband(0.0f) {
  }
};

struct Sdf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SdfT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Sdf";
  }
  enum {
    VT_DATA = 4,
    VT_DX = 6,
    VT_INNERBAND = 8,
    VT_OUTERBAND = 10
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  float dx() const {
    return GetField<float>(VT_DX, 0.0f);
  }
  float innerband() const {
    return GetField<float>(VT_INNERBAND, 0.0f);
  }
  float outerband() const {
    return GetField<float>(VT_OUTERBAND, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyField<float>(verifier, VT_DX) &&
           VerifyField<float>(verifier, VT_INNERBAND) &&
           VerifyField<float>(verifier, VT_OUTERBAND) &&
           verifier.EndTable();
  }
  SdfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SdfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sdf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SdfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SdfBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Sdf::VT_DATA, data);
  }
  void add_dx(float dx) {
    fbb_.AddElement<float>(Sdf::VT_DX, dx, 0.0f);
  }
  void add_innerband(float innerband) {
    fbb_.AddElement<float>(Sdf::VT_INNERBAND, innerband, 0.0f);
  }
  void add_outerband(float outerband) {
    fbb_.AddElement<float>(Sdf::VT_OUTERBAND, outerband, 0.0f);
  }
  explicit SdfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SdfBuilder &operator=(const SdfBuilder &);
  flatbuffers::Offset<Sdf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sdf>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sdf> CreateSdf(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    float dx = 0.0f,
    float innerband = 0.0f,
    float outerband = 0.0f) {
  SdfBuilder builder_(_fbb);
  builder_.add_outerband(outerband);
  builder_.add_innerband(innerband);
  builder_.add_dx(dx);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sdf> CreateSdfDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr,
    float dx = 0.0f,
    float innerband = 0.0f,
    float outerband = 0.0f) {
  return ARCSim::CreateSdf(
      _fbb,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0,
      dx,
      innerband,
      outerband);
}

flatbuffers::Offset<Sdf> CreateSdf(flatbuffers::FlatBufferBuilder &_fbb, const SdfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObstacleFrameT : public flatbuffers::NativeTable {
  typedef ObstacleFrame TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ObstacleFrameT";
  }
  std::unique_ptr<GeometryT> geometry;
  std::vector<std::unique_ptr<SdfT>> sdf_parts;
  uint32_t frame;
  uint32_t subframe;
  float timestamp;
  ObstacleFrameT()
      : frame(0),
        subframe(0),
        timestamp(0.0f) {
  }
};

struct ObstacleFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObstacleFrameT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ObstacleFrame";
  }
  enum {
    VT_GEOMETRY = 4,
    VT_SDF_PARTS = 6,
    VT_FRAME = 8,
    VT_SUBFRAME = 10,
    VT_TIMESTAMP = 12
  };
  const Geometry *geometry() const {
    return GetPointer<const Geometry *>(VT_GEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Sdf>> *sdf_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sdf>> *>(VT_SDF_PARTS);
  }
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint32_t subframe() const {
    return GetField<uint32_t>(VT_SUBFRAME, 0);
  }
  float timestamp() const {
    return GetField<float>(VT_TIMESTAMP, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyTable(geometry()) &&
           VerifyOffset(verifier, VT_SDF_PARTS) &&
           verifier.Verify(sdf_parts()) &&
           verifier.VerifyVectorOfTables(sdf_parts()) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint32_t>(verifier, VT_SUBFRAME) &&
           VerifyField<float>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
  ObstacleFrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObstacleFrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ObstacleFrame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObstacleFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geometry(flatbuffers::Offset<Geometry> geometry) {
    fbb_.AddOffset(ObstacleFrame::VT_GEOMETRY, geometry);
  }
  void add_sdf_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sdf>>> sdf_parts) {
    fbb_.AddOffset(ObstacleFrame::VT_SDF_PARTS, sdf_parts);
  }
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ObstacleFrame::VT_FRAME, frame, 0);
  }
  void add_subframe(uint32_t subframe) {
    fbb_.AddElement<uint32_t>(ObstacleFrame::VT_SUBFRAME, subframe, 0);
  }
  void add_timestamp(float timestamp) {
    fbb_.AddElement<float>(ObstacleFrame::VT_TIMESTAMP, timestamp, 0.0f);
  }
  explicit ObstacleFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObstacleFrameBuilder &operator=(const ObstacleFrameBuilder &);
  flatbuffers::Offset<ObstacleFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObstacleFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObstacleFrame> CreateObstacleFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Geometry> geometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sdf>>> sdf_parts = 0,
    uint32_t frame = 0,
    uint32_t subframe = 0,
    float timestamp = 0.0f) {
  ObstacleFrameBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_subframe(subframe);
  builder_.add_frame(frame);
  builder_.add_sdf_parts(sdf_parts);
  builder_.add_geometry(geometry);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObstacleFrame> CreateObstacleFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Geometry> geometry = 0,
    const std::vector<flatbuffers::Offset<Sdf>> *sdf_parts = nullptr,
    uint32_t frame = 0,
    uint32_t subframe = 0,
    float timestamp = 0.0f) {
  return ARCSim::CreateObstacleFrame(
      _fbb,
      geometry,
      sdf_parts ? _fbb.CreateVector<flatbuffers::Offset<Sdf>>(*sdf_parts) : 0,
      frame,
      subframe,
      timestamp);
}

flatbuffers::Offset<ObstacleFrame> CreateObstacleFrame(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObstacleT : public flatbuffers::NativeTable {
  typedef Obstacle TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ObstacleT";
  }
  std::string name;
  std::unique_ptr<GeometryT> initial_geometry;
  std::vector<std::unique_ptr<ObstacleFrameT>> frames;
  ObstacleT() {
  }
};

struct Obstacle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObstacleT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Obstacle";
  }
  enum {
    VT_NAME = 4,
    VT_INITIAL_GEOMETRY = 6,
    VT_FRAMES = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Geometry *initial_geometry() const {
    return GetPointer<const Geometry *>(VT_INITIAL_GEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ObstacleFrame>> *frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ObstacleFrame>> *>(VT_FRAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_INITIAL_GEOMETRY) &&
           verifier.VerifyTable(initial_geometry()) &&
           VerifyOffset(verifier, VT_FRAMES) &&
           verifier.Verify(frames()) &&
           verifier.VerifyVectorOfTables(frames()) &&
           verifier.EndTable();
  }
  ObstacleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObstacleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Obstacle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObstacleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Obstacle::VT_NAME, name);
  }
  void add_initial_geometry(flatbuffers::Offset<Geometry> initial_geometry) {
    fbb_.AddOffset(Obstacle::VT_INITIAL_GEOMETRY, initial_geometry);
  }
  void add_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObstacleFrame>>> frames) {
    fbb_.AddOffset(Obstacle::VT_FRAMES, frames);
  }
  explicit ObstacleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObstacleBuilder &operator=(const ObstacleBuilder &);
  flatbuffers::Offset<Obstacle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Obstacle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Obstacle> CreateObstacle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Geometry> initial_geometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObstacleFrame>>> frames = 0) {
  ObstacleBuilder builder_(_fbb);
  builder_.add_frames(frames);
  builder_.add_initial_geometry(initial_geometry);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Obstacle> CreateObstacleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Geometry> initial_geometry = 0,
    const std::vector<flatbuffers::Offset<ObstacleFrame>> *frames = nullptr) {
  return ARCSim::CreateObstacle(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      initial_geometry,
      frames ? _fbb.CreateVector<flatbuffers::Offset<ObstacleFrame>>(*frames) : 0);
}

flatbuffers::Offset<Obstacle> CreateObstacle(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StandardConstraintPropertiesT : public flatbuffers::NativeTable {
  typedef StandardConstraintProperties TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.StandardConstraintPropertiesT";
  }
  std::string name;
  float stiffness;
  uint16_t start_frame;
  uint16_t end_frame;
  StandardConstraintPropertiesT()
      : stiffness(0.0f),
        start_frame(0),
        end_frame(0) {
  }
};

struct StandardConstraintProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StandardConstraintPropertiesT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.StandardConstraintProperties";
  }
  enum {
    VT_NAME = 4,
    VT_STIFFNESS = 6,
    VT_START_FRAME = 8,
    VT_END_FRAME = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float stiffness() const {
    return GetField<float>(VT_STIFFNESS, 0.0f);
  }
  uint16_t start_frame() const {
    return GetField<uint16_t>(VT_START_FRAME, 0);
  }
  uint16_t end_frame() const {
    return GetField<uint16_t>(VT_END_FRAME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<float>(verifier, VT_STIFFNESS) &&
           VerifyField<uint16_t>(verifier, VT_START_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_END_FRAME) &&
           verifier.EndTable();
  }
  StandardConstraintPropertiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StandardConstraintPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StandardConstraintProperties> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StandardConstraintPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StandardConstraintPropertiesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(StandardConstraintProperties::VT_NAME, name);
  }
  void add_stiffness(float stiffness) {
    fbb_.AddElement<float>(StandardConstraintProperties::VT_STIFFNESS, stiffness, 0.0f);
  }
  void add_start_frame(uint16_t start_frame) {
    fbb_.AddElement<uint16_t>(StandardConstraintProperties::VT_START_FRAME, start_frame, 0);
  }
  void add_end_frame(uint16_t end_frame) {
    fbb_.AddElement<uint16_t>(StandardConstraintProperties::VT_END_FRAME, end_frame, 0);
  }
  explicit StandardConstraintPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StandardConstraintPropertiesBuilder &operator=(const StandardConstraintPropertiesBuilder &);
  flatbuffers::Offset<StandardConstraintProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StandardConstraintProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<StandardConstraintProperties> CreateStandardConstraintProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float stiffness = 0.0f,
    uint16_t start_frame = 0,
    uint16_t end_frame = 0) {
  StandardConstraintPropertiesBuilder builder_(_fbb);
  builder_.add_stiffness(stiffness);
  builder_.add_name(name);
  builder_.add_end_frame(end_frame);
  builder_.add_start_frame(start_frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<StandardConstraintProperties> CreateStandardConstraintPropertiesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float stiffness = 0.0f,
    uint16_t start_frame = 0,
    uint16_t end_frame = 0) {
  return ARCSim::CreateStandardConstraintProperties(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      stiffness,
      start_frame,
      end_frame);
}

flatbuffers::Offset<StandardConstraintProperties> CreateStandardConstraintProperties(flatbuffers::FlatBufferBuilder &_fbb, const StandardConstraintPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentsNodeT : public flatbuffers::NativeTable {
  typedef AttachmentsNode TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsNodeT";
  }
  std::vector<AttachmentNode> attachments;
  AttachmentsNodeT() {
  }
};

struct AttachmentsNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentsNodeT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsNode";
  }
  enum {
    VT_ATTACHMENTS = 4
  };
  const flatbuffers::Vector<const AttachmentNode *> *attachments() const {
    return GetPointer<const flatbuffers::Vector<const AttachmentNode *> *>(VT_ATTACHMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.Verify(attachments()) &&
           verifier.EndTable();
  }
  AttachmentsNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentsNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentsNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentsNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<const AttachmentNode *>> attachments) {
    fbb_.AddOffset(AttachmentsNode::VT_ATTACHMENTS, attachments);
  }
  explicit AttachmentsNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentsNodeBuilder &operator=(const AttachmentsNodeBuilder &);
  flatbuffers::Offset<AttachmentsNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentsNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentsNode> CreateAttachmentsNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const AttachmentNode *>> attachments = 0) {
  AttachmentsNodeBuilder builder_(_fbb);
  builder_.add_attachments(attachments);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttachmentsNode> CreateAttachmentsNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<AttachmentNode> *attachments = nullptr) {
  return ARCSim::CreateAttachmentsNode(
      _fbb,
      attachments ? _fbb.CreateVectorOfStructs<AttachmentNode>(*attachments) : 0);
}

flatbuffers::Offset<AttachmentsNode> CreateAttachmentsNode(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentsEdgeT : public flatbuffers::NativeTable {
  typedef AttachmentsEdge TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsEdgeT";
  }
  std::vector<AttachmentEdge> attachments;
  AttachmentsEdgeT() {
  }
};

struct AttachmentsEdge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentsEdgeT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsEdge";
  }
  enum {
    VT_ATTACHMENTS = 4
  };
  const flatbuffers::Vector<const AttachmentEdge *> *attachments() const {
    return GetPointer<const flatbuffers::Vector<const AttachmentEdge *> *>(VT_ATTACHMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.Verify(attachments()) &&
           verifier.EndTable();
  }
  AttachmentsEdgeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentsEdgeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentsEdge> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsEdgeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentsEdgeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<const AttachmentEdge *>> attachments) {
    fbb_.AddOffset(AttachmentsEdge::VT_ATTACHMENTS, attachments);
  }
  explicit AttachmentsEdgeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentsEdgeBuilder &operator=(const AttachmentsEdgeBuilder &);
  flatbuffers::Offset<AttachmentsEdge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentsEdge>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentsEdge> CreateAttachmentsEdge(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const AttachmentEdge *>> attachments = 0) {
  AttachmentsEdgeBuilder builder_(_fbb);
  builder_.add_attachments(attachments);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttachmentsEdge> CreateAttachmentsEdgeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<AttachmentEdge> *attachments = nullptr) {
  return ARCSim::CreateAttachmentsEdge(
      _fbb,
      attachments ? _fbb.CreateVectorOfStructs<AttachmentEdge>(*attachments) : 0);
}

flatbuffers::Offset<AttachmentsEdge> CreateAttachmentsEdge(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsEdgeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentMsT : public flatbuffers::NativeTable {
  typedef AttachmentMs TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentMsT";
  }
  std::unique_ptr<Vec2> ms_loc;
  AttachmentMsT() {
  }
};

struct AttachmentMs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentMsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentMs";
  }
  enum {
    VT_MS_LOC = 4
  };
  const Vec2 *ms_loc() const {
    return GetStruct<const Vec2 *>(VT_MS_LOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec2>(verifier, VT_MS_LOC) &&
           verifier.EndTable();
  }
  AttachmentMsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentMsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentMs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentMsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentMsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ms_loc(const Vec2 *ms_loc) {
    fbb_.AddStruct(AttachmentMs::VT_MS_LOC, ms_loc);
  }
  explicit AttachmentMsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentMsBuilder &operator=(const AttachmentMsBuilder &);
  flatbuffers::Offset<AttachmentMs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentMs>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentMs> CreateAttachmentMs(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec2 *ms_loc = 0) {
  AttachmentMsBuilder builder_(_fbb);
  builder_.add_ms_loc(ms_loc);
  return builder_.Finish();
}

flatbuffers::Offset<AttachmentMs> CreateAttachmentMs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentMsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentsMsT : public flatbuffers::NativeTable {
  typedef AttachmentsMs TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsMsT";
  }
  std::vector<std::unique_ptr<AttachmentMsT>> attachments;
  AttachmentsMsT() {
  }
};

struct AttachmentsMs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentsMsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsMs";
  }
  enum {
    VT_ATTACHMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AttachmentMs>> *attachments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AttachmentMs>> *>(VT_ATTACHMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.Verify(attachments()) &&
           verifier.VerifyVectorOfTables(attachments()) &&
           verifier.EndTable();
  }
  AttachmentsMsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentsMsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentsMs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsMsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentsMsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentMs>>> attachments) {
    fbb_.AddOffset(AttachmentsMs::VT_ATTACHMENTS, attachments);
  }
  explicit AttachmentsMsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentsMsBuilder &operator=(const AttachmentsMsBuilder &);
  flatbuffers::Offset<AttachmentsMs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentsMs>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentsMs> CreateAttachmentsMs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentMs>>> attachments = 0) {
  AttachmentsMsBuilder builder_(_fbb);
  builder_.add_attachments(attachments);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttachmentsMs> CreateAttachmentsMsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AttachmentMs>> *attachments = nullptr) {
  return ARCSim::CreateAttachmentsMs(
      _fbb,
      attachments ? _fbb.CreateVector<flatbuffers::Offset<AttachmentMs>>(*attachments) : 0);
}

flatbuffers::Offset<AttachmentsMs> CreateAttachmentsMs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsMsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentWsT : public flatbuffers::NativeTable {
  typedef AttachmentWs TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentWsT";
  }
  std::unique_ptr<Vec3> ws_loc;
  AttachmentWsT() {
  }
};

struct AttachmentWs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentWsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentWs";
  }
  enum {
    VT_WS_LOC = 4
  };
  const Vec3 *ws_loc() const {
    return GetStruct<const Vec3 *>(VT_WS_LOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_WS_LOC) &&
           verifier.EndTable();
  }
  AttachmentWsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentWsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentWs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentWsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentWsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ws_loc(const Vec3 *ws_loc) {
    fbb_.AddStruct(AttachmentWs::VT_WS_LOC, ws_loc);
  }
  explicit AttachmentWsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentWsBuilder &operator=(const AttachmentWsBuilder &);
  flatbuffers::Offset<AttachmentWs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentWs>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentWs> CreateAttachmentWs(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *ws_loc = 0) {
  AttachmentWsBuilder builder_(_fbb);
  builder_.add_ws_loc(ws_loc);
  return builder_.Finish();
}

flatbuffers::Offset<AttachmentWs> CreateAttachmentWs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentWsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentsWsT : public flatbuffers::NativeTable {
  typedef AttachmentsWs TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsWsT";
  }
  std::vector<std::unique_ptr<AttachmentWsT>> attachments;
  AttachmentsWsT() {
  }
};

struct AttachmentsWs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentsWsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsWs";
  }
  enum {
    VT_ATTACHMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AttachmentWs>> *attachments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AttachmentWs>> *>(VT_ATTACHMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.Verify(attachments()) &&
           verifier.VerifyVectorOfTables(attachments()) &&
           verifier.EndTable();
  }
  AttachmentsWsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentsWsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentsWs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsWsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentsWsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentWs>>> attachments) {
    fbb_.AddOffset(AttachmentsWs::VT_ATTACHMENTS, attachments);
  }
  explicit AttachmentsWsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentsWsBuilder &operator=(const AttachmentsWsBuilder &);
  flatbuffers::Offset<AttachmentsWs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentsWs>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentsWs> CreateAttachmentsWs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentWs>>> attachments = 0) {
  AttachmentsWsBuilder builder_(_fbb);
  builder_.add_attachments(attachments);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttachmentsWs> CreateAttachmentsWsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AttachmentWs>> *attachments = nullptr) {
  return ARCSim::CreateAttachmentsWs(
      _fbb,
      attachments ? _fbb.CreateVector<flatbuffers::Offset<AttachmentWs>>(*attachments) : 0);
}

flatbuffers::Offset<AttachmentsWs> CreateAttachmentsWs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsWsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentUVT : public flatbuffers::NativeTable {
  typedef AttachmentUV TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentUVT";
  }
  std::unique_ptr<Vec2> uv_loc;
  uint8_t channel;
  AttachmentUVT()
      : channel(0) {
  }
};

struct AttachmentUV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentUVT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentUV";
  }
  enum {
    VT_UV_LOC = 4,
    VT_CHANNEL = 6
  };
  const Vec2 *uv_loc() const {
    return GetStruct<const Vec2 *>(VT_UV_LOC);
  }
  uint8_t channel() const {
    return GetField<uint8_t>(VT_CHANNEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec2>(verifier, VT_UV_LOC) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL) &&
           verifier.EndTable();
  }
  AttachmentUVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentUVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentUV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentUVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentUVBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uv_loc(const Vec2 *uv_loc) {
    fbb_.AddStruct(AttachmentUV::VT_UV_LOC, uv_loc);
  }
  void add_channel(uint8_t channel) {
    fbb_.AddElement<uint8_t>(AttachmentUV::VT_CHANNEL, channel, 0);
  }
  explicit AttachmentUVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentUVBuilder &operator=(const AttachmentUVBuilder &);
  flatbuffers::Offset<AttachmentUV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentUV>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentUV> CreateAttachmentUV(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec2 *uv_loc = 0,
    uint8_t channel = 0) {
  AttachmentUVBuilder builder_(_fbb);
  builder_.add_uv_loc(uv_loc);
  builder_.add_channel(channel);
  return builder_.Finish();
}

flatbuffers::Offset<AttachmentUV> CreateAttachmentUV(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentUVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentsUVT : public flatbuffers::NativeTable {
  typedef AttachmentsUV TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsUVT";
  }
  std::vector<std::unique_ptr<AttachmentUVT>> attachments;
  AttachmentsUVT() {
  }
};

struct AttachmentsUV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentsUVT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsUV";
  }
  enum {
    VT_ATTACHMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AttachmentUV>> *attachments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AttachmentUV>> *>(VT_ATTACHMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.Verify(attachments()) &&
           verifier.VerifyVectorOfTables(attachments()) &&
           verifier.EndTable();
  }
  AttachmentsUVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentsUVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentsUV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsUVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentsUVBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentUV>>> attachments) {
    fbb_.AddOffset(AttachmentsUV::VT_ATTACHMENTS, attachments);
  }
  explicit AttachmentsUVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentsUVBuilder &operator=(const AttachmentsUVBuilder &);
  flatbuffers::Offset<AttachmentsUV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentsUV>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentsUV> CreateAttachmentsUV(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentUV>>> attachments = 0) {
  AttachmentsUVBuilder builder_(_fbb);
  builder_.add_attachments(attachments);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttachmentsUV> CreateAttachmentsUVDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AttachmentUV>> *attachments = nullptr) {
  return ARCSim::CreateAttachmentsUV(
      _fbb,
      attachments ? _fbb.CreateVector<flatbuffers::Offset<AttachmentUV>>(*attachments) : 0);
}

flatbuffers::Offset<AttachmentsUV> CreateAttachmentsUV(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsUVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentBaryT : public flatbuffers::NativeTable {
  typedef AttachmentBary TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentBaryT";
  }
  std::unique_ptr<Vec3> barycentric_coords;
  uint32_t face;
  AttachmentBaryT()
      : face(0) {
  }
};

struct AttachmentBary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentBaryT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentBary";
  }
  enum {
    VT_BARYCENTRIC_COORDS = 4,
    VT_FACE = 6
  };
  const Vec3 *barycentric_coords() const {
    return GetStruct<const Vec3 *>(VT_BARYCENTRIC_COORDS);
  }
  uint32_t face() const {
    return GetField<uint32_t>(VT_FACE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_BARYCENTRIC_COORDS) &&
           VerifyField<uint32_t>(verifier, VT_FACE) &&
           verifier.EndTable();
  }
  AttachmentBaryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentBaryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentBary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentBaryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentBaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_barycentric_coords(const Vec3 *barycentric_coords) {
    fbb_.AddStruct(AttachmentBary::VT_BARYCENTRIC_COORDS, barycentric_coords);
  }
  void add_face(uint32_t face) {
    fbb_.AddElement<uint32_t>(AttachmentBary::VT_FACE, face, 0);
  }
  explicit AttachmentBaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentBaryBuilder &operator=(const AttachmentBaryBuilder &);
  flatbuffers::Offset<AttachmentBary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentBary>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentBary> CreateAttachmentBary(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *barycentric_coords = 0,
    uint32_t face = 0) {
  AttachmentBaryBuilder builder_(_fbb);
  builder_.add_face(face);
  builder_.add_barycentric_coords(barycentric_coords);
  return builder_.Finish();
}

flatbuffers::Offset<AttachmentBary> CreateAttachmentBary(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentBaryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttachmentsBaryT : public flatbuffers::NativeTable {
  typedef AttachmentsBary TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsBaryT";
  }
  std::vector<std::unique_ptr<AttachmentBaryT>> attachments;
  AttachmentsBaryT() {
  }
};

struct AttachmentsBary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentsBaryT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.AttachmentsBary";
  }
  enum {
    VT_ATTACHMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AttachmentBary>> *attachments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AttachmentBary>> *>(VT_ATTACHMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.Verify(attachments()) &&
           verifier.VerifyVectorOfTables(attachments()) &&
           verifier.EndTable();
  }
  AttachmentsBaryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttachmentsBaryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttachmentsBary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsBaryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttachmentsBaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentBary>>> attachments) {
    fbb_.AddOffset(AttachmentsBary::VT_ATTACHMENTS, attachments);
  }
  explicit AttachmentsBaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentsBaryBuilder &operator=(const AttachmentsBaryBuilder &);
  flatbuffers::Offset<AttachmentsBary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttachmentsBary>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttachmentsBary> CreateAttachmentsBary(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttachmentBary>>> attachments = 0) {
  AttachmentsBaryBuilder builder_(_fbb);
  builder_.add_attachments(attachments);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttachmentsBary> CreateAttachmentsBaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AttachmentBary>> *attachments = nullptr) {
  return ARCSim::CreateAttachmentsBary(
      _fbb,
      attachments ? _fbb.CreateVector<flatbuffers::Offset<AttachmentBary>>(*attachments) : 0);
}

flatbuffers::Offset<AttachmentsBary> CreateAttachmentsBary(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsBaryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NodeConstraintT : public flatbuffers::NativeTable {
  typedef NodeConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.NodeConstraintT";
  }
  std::unique_ptr<AttachmentsNodeT> cloth_attachment;
  NodeConstraintT() {
  }
};

struct NodeConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.NodeConstraint";
  }
  enum {
    VT_CLOTH_ATTACHMENT = 4
  };
  const AttachmentsNode *cloth_attachment() const {
    return GetPointer<const AttachmentsNode *>(VT_CLOTH_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           verifier.EndTable();
  }
  NodeConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NodeConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsNode> cloth_attachment) {
    fbb_.AddOffset(NodeConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  explicit NodeConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeConstraintBuilder &operator=(const NodeConstraintBuilder &);
  flatbuffers::Offset<NodeConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeConstraint> CreateNodeConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttachmentsNode> cloth_attachment = 0) {
  NodeConstraintBuilder builder_(_fbb);
  builder_.add_cloth_attachment(cloth_attachment);
  return builder_.Finish();
}

flatbuffers::Offset<NodeConstraint> CreateNodeConstraint(flatbuffers::FlatBufferBuilder &_fbb, const NodeConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ForceConstraintT : public flatbuffers::NativeTable {
  typedef ForceConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ForceConstraintT";
  }
  std::unique_ptr<Vec3> direction;
  ClothAttachmentUnion cloth_attachment;
  ForceConstraintT() {
  }
};

struct ForceConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ForceConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ForceConstraint";
  }
  enum {
    VT_DIRECTION = 4,
    VT_CLOTH_ATTACHMENT_TYPE = 6,
    VT_CLOTH_ATTACHMENT = 8
  };
  const Vec3 *direction() const {
    return GetStruct<const Vec3 *>(VT_DIRECTION);
  }
  ClothAttachment cloth_attachment_type() const {
    return static_cast<ClothAttachment>(GetField<uint8_t>(VT_CLOTH_ATTACHMENT_TYPE, 0));
  }
  const void *cloth_attachment() const {
    return GetPointer<const void *>(VT_CLOTH_ATTACHMENT);
  }
  template<typename T> const T *cloth_attachment_as() const;
  const AttachmentsEdge *cloth_attachment_as_AttachmentsEdge() const {
    return cloth_attachment_type() == ClothAttachment::AttachmentsEdge ? static_cast<const AttachmentsEdge *>(cloth_attachment()) : nullptr;
  }
  const AttachmentsMs *cloth_attachment_as_AttachmentsMs() const {
    return cloth_attachment_type() == ClothAttachment::AttachmentsMs ? static_cast<const AttachmentsMs *>(cloth_attachment()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_DIRECTION) &&
           VerifyField<uint8_t>(verifier, VT_CLOTH_ATTACHMENT_TYPE) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           VerifyClothAttachment(verifier, cloth_attachment(), cloth_attachment_type()) &&
           verifier.EndTable();
  }
  ForceConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ForceConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ForceConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ForceConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const AttachmentsEdge *ForceConstraint::cloth_attachment_as<AttachmentsEdge>() const {
  return cloth_attachment_as_AttachmentsEdge();
}

template<> inline const AttachmentsMs *ForceConstraint::cloth_attachment_as<AttachmentsMs>() const {
  return cloth_attachment_as_AttachmentsMs();
}

struct ForceConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_direction(const Vec3 *direction) {
    fbb_.AddStruct(ForceConstraint::VT_DIRECTION, direction);
  }
  void add_cloth_attachment_type(ClothAttachment cloth_attachment_type) {
    fbb_.AddElement<uint8_t>(ForceConstraint::VT_CLOTH_ATTACHMENT_TYPE, static_cast<uint8_t>(cloth_attachment_type), 0);
  }
  void add_cloth_attachment(flatbuffers::Offset<void> cloth_attachment) {
    fbb_.AddOffset(ForceConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  explicit ForceConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ForceConstraintBuilder &operator=(const ForceConstraintBuilder &);
  flatbuffers::Offset<ForceConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ForceConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<ForceConstraint> CreateForceConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *direction = 0,
    ClothAttachment cloth_attachment_type = ClothAttachment::NONE,
    flatbuffers::Offset<void> cloth_attachment = 0) {
  ForceConstraintBuilder builder_(_fbb);
  builder_.add_cloth_attachment(cloth_attachment);
  builder_.add_direction(direction);
  builder_.add_cloth_attachment_type(cloth_attachment_type);
  return builder_.Finish();
}

flatbuffers::Offset<ForceConstraint> CreateForceConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ForceConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PinConstraintT : public flatbuffers::NativeTable {
  typedef PinConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.PinConstraintT";
  }
  float slack;
  std::unique_ptr<AttachmentsMsT> cloth_attachment;
  ObstacleAttachmentUnion body_attachment;
  PinConstraintT()
      : slack(0.0f) {
  }
};

struct PinConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PinConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.PinConstraint";
  }
  enum {
    VT_SLACK = 4,
    VT_CLOTH_ATTACHMENT = 6,
    VT_BODY_ATTACHMENT_TYPE = 8,
    VT_BODY_ATTACHMENT = 10
  };
  float slack() const {
    return GetField<float>(VT_SLACK, 0.0f);
  }
  const AttachmentsMs *cloth_attachment() const {
    return GetPointer<const AttachmentsMs *>(VT_CLOTH_ATTACHMENT);
  }
  ObstacleAttachment body_attachment_type() const {
    return static_cast<ObstacleAttachment>(GetField<uint8_t>(VT_BODY_ATTACHMENT_TYPE, 0));
  }
  const void *body_attachment() const {
    return GetPointer<const void *>(VT_BODY_ATTACHMENT);
  }
  template<typename T> const T *body_attachment_as() const;
  const AttachmentsUV *body_attachment_as_AttachmentsUV() const {
    return body_attachment_type() == ObstacleAttachment::AttachmentsUV ? static_cast<const AttachmentsUV *>(body_attachment()) : nullptr;
  }
  const AttachmentsBary *body_attachment_as_AttachmentsBary() const {
    return body_attachment_type() == ObstacleAttachment::AttachmentsBary ? static_cast<const AttachmentsBary *>(body_attachment()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLACK) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           VerifyField<uint8_t>(verifier, VT_BODY_ATTACHMENT_TYPE) &&
           VerifyOffset(verifier, VT_BODY_ATTACHMENT) &&
           VerifyObstacleAttachment(verifier, body_attachment(), body_attachment_type()) &&
           verifier.EndTable();
  }
  PinConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PinConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PinConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PinConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const AttachmentsUV *PinConstraint::body_attachment_as<AttachmentsUV>() const {
  return body_attachment_as_AttachmentsUV();
}

template<> inline const AttachmentsBary *PinConstraint::body_attachment_as<AttachmentsBary>() const {
  return body_attachment_as_AttachmentsBary();
}

struct PinConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slack(float slack) {
    fbb_.AddElement<float>(PinConstraint::VT_SLACK, slack, 0.0f);
  }
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsMs> cloth_attachment) {
    fbb_.AddOffset(PinConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  void add_body_attachment_type(ObstacleAttachment body_attachment_type) {
    fbb_.AddElement<uint8_t>(PinConstraint::VT_BODY_ATTACHMENT_TYPE, static_cast<uint8_t>(body_attachment_type), 0);
  }
  void add_body_attachment(flatbuffers::Offset<void> body_attachment) {
    fbb_.AddOffset(PinConstraint::VT_BODY_ATTACHMENT, body_attachment);
  }
  explicit PinConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PinConstraintBuilder &operator=(const PinConstraintBuilder &);
  flatbuffers::Offset<PinConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PinConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<PinConstraint> CreatePinConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slack = 0.0f,
    flatbuffers::Offset<AttachmentsMs> cloth_attachment = 0,
    ObstacleAttachment body_attachment_type = ObstacleAttachment::NONE,
    flatbuffers::Offset<void> body_attachment = 0) {
  PinConstraintBuilder builder_(_fbb);
  builder_.add_body_attachment(body_attachment);
  builder_.add_cloth_attachment(cloth_attachment);
  builder_.add_slack(slack);
  builder_.add_body_attachment_type(body_attachment_type);
  return builder_.Finish();
}

flatbuffers::Offset<PinConstraint> CreatePinConstraint(flatbuffers::FlatBufferBuilder &_fbb, const PinConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CenteringConstraintT : public flatbuffers::NativeTable {
  typedef CenteringConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.CenteringConstraintT";
  }
  std::unique_ptr<AttachmentsEdgeT> cloth_attachment;
  CenteringConstraintT() {
  }
};

struct CenteringConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CenteringConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.CenteringConstraint";
  }
  enum {
    VT_CLOTH_ATTACHMENT = 4
  };
  const AttachmentsEdge *cloth_attachment() const {
    return GetPointer<const AttachmentsEdge *>(VT_CLOTH_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           verifier.EndTable();
  }
  CenteringConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CenteringConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CenteringConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CenteringConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CenteringConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsEdge> cloth_attachment) {
    fbb_.AddOffset(CenteringConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  explicit CenteringConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CenteringConstraintBuilder &operator=(const CenteringConstraintBuilder &);
  flatbuffers::Offset<CenteringConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CenteringConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<CenteringConstraint> CreateCenteringConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttachmentsEdge> cloth_attachment = 0) {
  CenteringConstraintBuilder builder_(_fbb);
  builder_.add_cloth_attachment(cloth_attachment);
  return builder_.Finish();
}

flatbuffers::Offset<CenteringConstraint> CreateCenteringConstraint(flatbuffers::FlatBufferBuilder &_fbb, const CenteringConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BarrierConstraintT : public flatbuffers::NativeTable {
  typedef BarrierConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.BarrierConstraintT";
  }
  bool animate_normal;
  std::unique_ptr<Vec3> normal;
  std::unique_ptr<AttachmentsEdgeT> cloth_attachment;
  ObstacleAttachmentUnion body_attachment;
  BarrierConstraintT()
      : animate_normal(false) {
  }
};

struct BarrierConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrierConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.BarrierConstraint";
  }
  enum {
    VT_ANIMATE_NORMAL = 4,
    VT_NORMAL = 6,
    VT_CLOTH_ATTACHMENT = 8,
    VT_BODY_ATTACHMENT_TYPE = 10,
    VT_BODY_ATTACHMENT = 12
  };
  bool animate_normal() const {
    return GetField<uint8_t>(VT_ANIMATE_NORMAL, 0) != 0;
  }
  const Vec3 *normal() const {
    return GetStruct<const Vec3 *>(VT_NORMAL);
  }
  const AttachmentsEdge *cloth_attachment() const {
    return GetPointer<const AttachmentsEdge *>(VT_CLOTH_ATTACHMENT);
  }
  ObstacleAttachment body_attachment_type() const {
    return static_cast<ObstacleAttachment>(GetField<uint8_t>(VT_BODY_ATTACHMENT_TYPE, 0));
  }
  const void *body_attachment() const {
    return GetPointer<const void *>(VT_BODY_ATTACHMENT);
  }
  template<typename T> const T *body_attachment_as() const;
  const AttachmentsUV *body_attachment_as_AttachmentsUV() const {
    return body_attachment_type() == ObstacleAttachment::AttachmentsUV ? static_cast<const AttachmentsUV *>(body_attachment()) : nullptr;
  }
  const AttachmentsBary *body_attachment_as_AttachmentsBary() const {
    return body_attachment_type() == ObstacleAttachment::AttachmentsBary ? static_cast<const AttachmentsBary *>(body_attachment()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANIMATE_NORMAL) &&
           VerifyField<Vec3>(verifier, VT_NORMAL) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           VerifyField<uint8_t>(verifier, VT_BODY_ATTACHMENT_TYPE) &&
           VerifyOffset(verifier, VT_BODY_ATTACHMENT) &&
           VerifyObstacleAttachment(verifier, body_attachment(), body_attachment_type()) &&
           verifier.EndTable();
  }
  BarrierConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BarrierConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BarrierConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const AttachmentsUV *BarrierConstraint::body_attachment_as<AttachmentsUV>() const {
  return body_attachment_as_AttachmentsUV();
}

template<> inline const AttachmentsBary *BarrierConstraint::body_attachment_as<AttachmentsBary>() const {
  return body_attachment_as_AttachmentsBary();
}

struct BarrierConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_animate_normal(bool animate_normal) {
    fbb_.AddElement<uint8_t>(BarrierConstraint::VT_ANIMATE_NORMAL, static_cast<uint8_t>(animate_normal), 0);
  }
  void add_normal(const Vec3 *normal) {
    fbb_.AddStruct(BarrierConstraint::VT_NORMAL, normal);
  }
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsEdge> cloth_attachment) {
    fbb_.AddOffset(BarrierConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  void add_body_attachment_type(ObstacleAttachment body_attachment_type) {
    fbb_.AddElement<uint8_t>(BarrierConstraint::VT_BODY_ATTACHMENT_TYPE, static_cast<uint8_t>(body_attachment_type), 0);
  }
  void add_body_attachment(flatbuffers::Offset<void> body_attachment) {
    fbb_.AddOffset(BarrierConstraint::VT_BODY_ATTACHMENT, body_attachment);
  }
  explicit BarrierConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BarrierConstraintBuilder &operator=(const BarrierConstraintBuilder &);
  flatbuffers::Offset<BarrierConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrierConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrierConstraint> CreateBarrierConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool animate_normal = false,
    const Vec3 *normal = 0,
    flatbuffers::Offset<AttachmentsEdge> cloth_attachment = 0,
    ObstacleAttachment body_attachment_type = ObstacleAttachment::NONE,
    flatbuffers::Offset<void> body_attachment = 0) {
  BarrierConstraintBuilder builder_(_fbb);
  builder_.add_body_attachment(body_attachment);
  builder_.add_cloth_attachment(cloth_attachment);
  builder_.add_normal(normal);
  builder_.add_body_attachment_type(body_attachment_type);
  builder_.add_animate_normal(animate_normal);
  return builder_.Finish();
}

flatbuffers::Offset<BarrierConstraint> CreateBarrierConstraint(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BeltConstraintT : public flatbuffers::NativeTable {
  typedef BeltConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.BeltConstraintT";
  }
  float slack;
  bool animate_normal;
  std::unique_ptr<Vec3> normal;
  std::unique_ptr<AttachmentsEdgeT> cloth_attachment;
  ObstacleAttachmentUnion body_attachment;
  BeltConstraintT()
      : slack(0.0f),
        animate_normal(false) {
  }
};

struct BeltConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BeltConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.BeltConstraint";
  }
  enum {
    VT_SLACK = 4,
    VT_ANIMATE_NORMAL = 6,
    VT_NORMAL = 8,
    VT_CLOTH_ATTACHMENT = 10,
    VT_BODY_ATTACHMENT_TYPE = 12,
    VT_BODY_ATTACHMENT = 14
  };
  float slack() const {
    return GetField<float>(VT_SLACK, 0.0f);
  }
  bool animate_normal() const {
    return GetField<uint8_t>(VT_ANIMATE_NORMAL, 0) != 0;
  }
  const Vec3 *normal() const {
    return GetStruct<const Vec3 *>(VT_NORMAL);
  }
  const AttachmentsEdge *cloth_attachment() const {
    return GetPointer<const AttachmentsEdge *>(VT_CLOTH_ATTACHMENT);
  }
  ObstacleAttachment body_attachment_type() const {
    return static_cast<ObstacleAttachment>(GetField<uint8_t>(VT_BODY_ATTACHMENT_TYPE, 0));
  }
  const void *body_attachment() const {
    return GetPointer<const void *>(VT_BODY_ATTACHMENT);
  }
  template<typename T> const T *body_attachment_as() const;
  const AttachmentsUV *body_attachment_as_AttachmentsUV() const {
    return body_attachment_type() == ObstacleAttachment::AttachmentsUV ? static_cast<const AttachmentsUV *>(body_attachment()) : nullptr;
  }
  const AttachmentsBary *body_attachment_as_AttachmentsBary() const {
    return body_attachment_type() == ObstacleAttachment::AttachmentsBary ? static_cast<const AttachmentsBary *>(body_attachment()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLACK) &&
           VerifyField<uint8_t>(verifier, VT_ANIMATE_NORMAL) &&
           VerifyField<Vec3>(verifier, VT_NORMAL) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           VerifyField<uint8_t>(verifier, VT_BODY_ATTACHMENT_TYPE) &&
           VerifyOffset(verifier, VT_BODY_ATTACHMENT) &&
           VerifyObstacleAttachment(verifier, body_attachment(), body_attachment_type()) &&
           verifier.EndTable();
  }
  BeltConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BeltConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BeltConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BeltConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const AttachmentsUV *BeltConstraint::body_attachment_as<AttachmentsUV>() const {
  return body_attachment_as_AttachmentsUV();
}

template<> inline const AttachmentsBary *BeltConstraint::body_attachment_as<AttachmentsBary>() const {
  return body_attachment_as_AttachmentsBary();
}

struct BeltConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slack(float slack) {
    fbb_.AddElement<float>(BeltConstraint::VT_SLACK, slack, 0.0f);
  }
  void add_animate_normal(bool animate_normal) {
    fbb_.AddElement<uint8_t>(BeltConstraint::VT_ANIMATE_NORMAL, static_cast<uint8_t>(animate_normal), 0);
  }
  void add_normal(const Vec3 *normal) {
    fbb_.AddStruct(BeltConstraint::VT_NORMAL, normal);
  }
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsEdge> cloth_attachment) {
    fbb_.AddOffset(BeltConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  void add_body_attachment_type(ObstacleAttachment body_attachment_type) {
    fbb_.AddElement<uint8_t>(BeltConstraint::VT_BODY_ATTACHMENT_TYPE, static_cast<uint8_t>(body_attachment_type), 0);
  }
  void add_body_attachment(flatbuffers::Offset<void> body_attachment) {
    fbb_.AddOffset(BeltConstraint::VT_BODY_ATTACHMENT, body_attachment);
  }
  explicit BeltConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BeltConstraintBuilder &operator=(const BeltConstraintBuilder &);
  flatbuffers::Offset<BeltConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BeltConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<BeltConstraint> CreateBeltConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slack = 0.0f,
    bool animate_normal = false,
    const Vec3 *normal = 0,
    flatbuffers::Offset<AttachmentsEdge> cloth_attachment = 0,
    ObstacleAttachment body_attachment_type = ObstacleAttachment::NONE,
    flatbuffers::Offset<void> body_attachment = 0) {
  BeltConstraintBuilder builder_(_fbb);
  builder_.add_body_attachment(body_attachment);
  builder_.add_cloth_attachment(cloth_attachment);
  builder_.add_normal(normal);
  builder_.add_slack(slack);
  builder_.add_body_attachment_type(body_attachment_type);
  builder_.add_animate_normal(animate_normal);
  return builder_.Finish();
}

flatbuffers::Offset<BeltConstraint> CreateBeltConstraint(flatbuffers::FlatBufferBuilder &_fbb, const BeltConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ElasticConstraintT : public flatbuffers::NativeTable {
  typedef ElasticConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ElasticConstraintT";
  }
  float target_length;
  std::unique_ptr<AttachmentsEdgeT> cloth_attachment;
  ElasticConstraintT()
      : target_length(0.0f) {
  }
};

struct ElasticConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ElasticConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ElasticConstraint";
  }
  enum {
    VT_TARGET_LENGTH = 4,
    VT_CLOTH_ATTACHMENT = 6
  };
  float target_length() const {
    return GetField<float>(VT_TARGET_LENGTH, 0.0f);
  }
  const AttachmentsEdge *cloth_attachment() const {
    return GetPointer<const AttachmentsEdge *>(VT_CLOTH_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TARGET_LENGTH) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           verifier.EndTable();
  }
  ElasticConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ElasticConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ElasticConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElasticConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ElasticConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target_length(float target_length) {
    fbb_.AddElement<float>(ElasticConstraint::VT_TARGET_LENGTH, target_length, 0.0f);
  }
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsEdge> cloth_attachment) {
    fbb_.AddOffset(ElasticConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  explicit ElasticConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElasticConstraintBuilder &operator=(const ElasticConstraintBuilder &);
  flatbuffers::Offset<ElasticConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElasticConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElasticConstraint> CreateElasticConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    float target_length = 0.0f,
    flatbuffers::Offset<AttachmentsEdge> cloth_attachment = 0) {
  ElasticConstraintBuilder builder_(_fbb);
  builder_.add_cloth_attachment(cloth_attachment);
  builder_.add_target_length(target_length);
  return builder_.Finish();
}

flatbuffers::Offset<ElasticConstraint> CreateElasticConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ElasticConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ButtonConstraintT : public flatbuffers::NativeTable {
  typedef ButtonConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ButtonConstraintT";
  }
  std::unique_ptr<AttachmentsMsT> cloth_attachment;
  ButtonConstraintT() {
  }
};

struct ButtonConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ButtonConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ButtonConstraint";
  }
  enum {
    VT_CLOTH_ATTACHMENT = 4
  };
  const AttachmentsMs *cloth_attachment() const {
    return GetPointer<const AttachmentsMs *>(VT_CLOTH_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           verifier.EndTable();
  }
  ButtonConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ButtonConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ButtonConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ButtonConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ButtonConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsMs> cloth_attachment) {
    fbb_.AddOffset(ButtonConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  explicit ButtonConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ButtonConstraintBuilder &operator=(const ButtonConstraintBuilder &);
  flatbuffers::Offset<ButtonConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ButtonConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<ButtonConstraint> CreateButtonConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttachmentsMs> cloth_attachment = 0) {
  ButtonConstraintBuilder builder_(_fbb);
  builder_.add_cloth_attachment(cloth_attachment);
  return builder_.Finish();
}

flatbuffers::Offset<ButtonConstraint> CreateButtonConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ButtonConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OrientedButtonConstraintT : public flatbuffers::NativeTable {
  typedef OrientedButtonConstraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.OrientedButtonConstraintT";
  }
  std::unique_ptr<AttachmentsMsT> cloth_attachment;
  OrientedButtonConstraintT() {
  }
};

struct OrientedButtonConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrientedButtonConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.OrientedButtonConstraint";
  }
  enum {
    VT_CLOTH_ATTACHMENT = 4
  };
  const AttachmentsMs *cloth_attachment() const {
    return GetPointer<const AttachmentsMs *>(VT_CLOTH_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLOTH_ATTACHMENT) &&
           verifier.VerifyTable(cloth_attachment()) &&
           verifier.EndTable();
  }
  OrientedButtonConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OrientedButtonConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OrientedButtonConstraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrientedButtonConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OrientedButtonConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cloth_attachment(flatbuffers::Offset<AttachmentsMs> cloth_attachment) {
    fbb_.AddOffset(OrientedButtonConstraint::VT_CLOTH_ATTACHMENT, cloth_attachment);
  }
  explicit OrientedButtonConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrientedButtonConstraintBuilder &operator=(const OrientedButtonConstraintBuilder &);
  flatbuffers::Offset<OrientedButtonConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrientedButtonConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrientedButtonConstraint> CreateOrientedButtonConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttachmentsMs> cloth_attachment = 0) {
  OrientedButtonConstraintBuilder builder_(_fbb);
  builder_.add_cloth_attachment(cloth_attachment);
  return builder_.Finish();
}

flatbuffers::Offset<OrientedButtonConstraint> CreateOrientedButtonConstraint(flatbuffers::FlatBufferBuilder &_fbb, const OrientedButtonConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstraintT : public flatbuffers::NativeTable {
  typedef Constraint TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.ConstraintT";
  }
  ConstraintType type;
  std::unique_ptr<StandardConstraintPropertiesT> standard_props;
  std::unique_ptr<NodeConstraintT> node;
  std::unique_ptr<ForceConstraintT> force;
  std::unique_ptr<PinConstraintT> pin;
  std::unique_ptr<CenteringConstraintT> centering;
  std::unique_ptr<BarrierConstraintT> barrier;
  std::unique_ptr<BeltConstraintT> belt;
  std::unique_ptr<ElasticConstraintT> elastic;
  std::unique_ptr<ButtonConstraintT> button;
  std::unique_ptr<OrientedButtonConstraintT> oriented_button;
  ConstraintT()
      : type(ConstraintType::Node) {
  }
};

struct Constraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstraintT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Constraint";
  }
  enum {
    VT_TYPE = 4,
    VT_STANDARD_PROPS = 6,
    VT_NODE = 8,
    VT_FORCE = 10,
    VT_PIN = 12,
    VT_CENTERING = 14,
    VT_BARRIER = 16,
    VT_BELT = 18,
    VT_ELASTIC = 20,
    VT_BUTTON = 22,
    VT_ORIENTED_BUTTON = 24
  };
  ConstraintType type() const {
    return static_cast<ConstraintType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const StandardConstraintProperties *standard_props() const {
    return GetPointer<const StandardConstraintProperties *>(VT_STANDARD_PROPS);
  }
  const NodeConstraint *node() const {
    return GetPointer<const NodeConstraint *>(VT_NODE);
  }
  const ForceConstraint *force() const {
    return GetPointer<const ForceConstraint *>(VT_FORCE);
  }
  const PinConstraint *pin() const {
    return GetPointer<const PinConstraint *>(VT_PIN);
  }
  const CenteringConstraint *centering() const {
    return GetPointer<const CenteringConstraint *>(VT_CENTERING);
  }
  const BarrierConstraint *barrier() const {
    return GetPointer<const BarrierConstraint *>(VT_BARRIER);
  }
  const BeltConstraint *belt() const {
    return GetPointer<const BeltConstraint *>(VT_BELT);
  }
  const ElasticConstraint *elastic() const {
    return GetPointer<const ElasticConstraint *>(VT_ELASTIC);
  }
  const ButtonConstraint *button() const {
    return GetPointer<const ButtonConstraint *>(VT_BUTTON);
  }
  const OrientedButtonConstraint *oriented_button() const {
    return GetPointer<const OrientedButtonConstraint *>(VT_ORIENTED_BUTTON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_STANDARD_PROPS) &&
           verifier.VerifyTable(standard_props()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyOffset(verifier, VT_FORCE) &&
           verifier.VerifyTable(force()) &&
           VerifyOffset(verifier, VT_PIN) &&
           verifier.VerifyTable(pin()) &&
           VerifyOffset(verifier, VT_CENTERING) &&
           verifier.VerifyTable(centering()) &&
           VerifyOffset(verifier, VT_BARRIER) &&
           verifier.VerifyTable(barrier()) &&
           VerifyOffset(verifier, VT_BELT) &&
           verifier.VerifyTable(belt()) &&
           VerifyOffset(verifier, VT_ELASTIC) &&
           verifier.VerifyTable(elastic()) &&
           VerifyOffset(verifier, VT_BUTTON) &&
           verifier.VerifyTable(button()) &&
           VerifyOffset(verifier, VT_ORIENTED_BUTTON) &&
           verifier.VerifyTable(oriented_button()) &&
           verifier.EndTable();
  }
  ConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Constraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ConstraintType type) {
    fbb_.AddElement<int8_t>(Constraint::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_standard_props(flatbuffers::Offset<StandardConstraintProperties> standard_props) {
    fbb_.AddOffset(Constraint::VT_STANDARD_PROPS, standard_props);
  }
  void add_node(flatbuffers::Offset<NodeConstraint> node) {
    fbb_.AddOffset(Constraint::VT_NODE, node);
  }
  void add_force(flatbuffers::Offset<ForceConstraint> force) {
    fbb_.AddOffset(Constraint::VT_FORCE, force);
  }
  void add_pin(flatbuffers::Offset<PinConstraint> pin) {
    fbb_.AddOffset(Constraint::VT_PIN, pin);
  }
  void add_centering(flatbuffers::Offset<CenteringConstraint> centering) {
    fbb_.AddOffset(Constraint::VT_CENTERING, centering);
  }
  void add_barrier(flatbuffers::Offset<BarrierConstraint> barrier) {
    fbb_.AddOffset(Constraint::VT_BARRIER, barrier);
  }
  void add_belt(flatbuffers::Offset<BeltConstraint> belt) {
    fbb_.AddOffset(Constraint::VT_BELT, belt);
  }
  void add_elastic(flatbuffers::Offset<ElasticConstraint> elastic) {
    fbb_.AddOffset(Constraint::VT_ELASTIC, elastic);
  }
  void add_button(flatbuffers::Offset<ButtonConstraint> button) {
    fbb_.AddOffset(Constraint::VT_BUTTON, button);
  }
  void add_oriented_button(flatbuffers::Offset<OrientedButtonConstraint> oriented_button) {
    fbb_.AddOffset(Constraint::VT_ORIENTED_BUTTON, oriented_button);
  }
  explicit ConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstraintBuilder &operator=(const ConstraintBuilder &);
  flatbuffers::Offset<Constraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Constraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Constraint> CreateConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    ConstraintType type = ConstraintType::Node,
    flatbuffers::Offset<StandardConstraintProperties> standard_props = 0,
    flatbuffers::Offset<NodeConstraint> node = 0,
    flatbuffers::Offset<ForceConstraint> force = 0,
    flatbuffers::Offset<PinConstraint> pin = 0,
    flatbuffers::Offset<CenteringConstraint> centering = 0,
    flatbuffers::Offset<BarrierConstraint> barrier = 0,
    flatbuffers::Offset<BeltConstraint> belt = 0,
    flatbuffers::Offset<ElasticConstraint> elastic = 0,
    flatbuffers::Offset<ButtonConstraint> button = 0,
    flatbuffers::Offset<OrientedButtonConstraint> oriented_button = 0) {
  ConstraintBuilder builder_(_fbb);
  builder_.add_oriented_button(oriented_button);
  builder_.add_button(button);
  builder_.add_elastic(elastic);
  builder_.add_belt(belt);
  builder_.add_barrier(barrier);
  builder_.add_centering(centering);
  builder_.add_pin(pin);
  builder_.add_force(force);
  builder_.add_node(node);
  builder_.add_standard_props(standard_props);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Constraint> CreateConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SimulationPropertiesT : public flatbuffers::NativeTable {
  typedef SimulationProperties TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.SimulationPropertiesT";
  }
  SimulationPropertiesT() {
  }
};

struct SimulationProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimulationPropertiesT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.SimulationProperties";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SimulationPropertiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SimulationPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SimulationProperties> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimulationPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SimulationPropertiesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SimulationPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimulationPropertiesBuilder &operator=(const SimulationPropertiesBuilder &);
  flatbuffers::Offset<SimulationProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimulationProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimulationProperties> CreateSimulationProperties(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SimulationPropertiesBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SimulationProperties> CreateSimulationProperties(flatbuffers::FlatBufferBuilder &_fbb, const SimulationPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StichingPropertiesT : public flatbuffers::NativeTable {
  typedef StichingProperties TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.StichingPropertiesT";
  }
  StichingPropertiesT() {
  }
};

struct StichingProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StichingPropertiesT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.StichingProperties";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StichingPropertiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StichingPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StichingProperties> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StichingPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StichingPropertiesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StichingPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StichingPropertiesBuilder &operator=(const StichingPropertiesBuilder &);
  flatbuffers::Offset<StichingProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StichingProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<StichingProperties> CreateStichingProperties(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StichingPropertiesBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<StichingProperties> CreateStichingProperties(flatbuffers::FlatBufferBuilder &_fbb, const StichingPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshingPropertiesT : public flatbuffers::NativeTable {
  typedef MeshingProperties TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.MeshingPropertiesT";
  }
  MeshingPropertiesT() {
  }
};

struct MeshingProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshingPropertiesT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.MeshingProperties";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MeshingPropertiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshingPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeshingProperties> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshingPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshingPropertiesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MeshingPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshingPropertiesBuilder &operator=(const MeshingPropertiesBuilder &);
  flatbuffers::Offset<MeshingProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshingProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshingProperties> CreateMeshingProperties(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MeshingPropertiesBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MeshingProperties> CreateMeshingProperties(flatbuffers::FlatBufferBuilder &_fbb, const MeshingPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SceneT : public flatbuffers::NativeTable {
  typedef Scene TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.SceneT";
  }
  std::vector<std::unique_ptr<GarmentT>> garments;
  std::vector<std::unique_ptr<ObstacleT>> obstacles;
  std::vector<std::unique_ptr<ConstraintT>> constraints;
  std::unique_ptr<SimulationPropertiesT> simulation_properties;
  std::unique_ptr<StichingPropertiesT> stitching_properties;
  std::unique_ptr<MeshingPropertiesT> meshing_properties;
  SceneT() {
  }
};

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SceneT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ARCSim.Scene";
  }
  enum {
    VT_GARMENTS = 4,
    VT_OBSTACLES = 6,
    VT_CONSTRAINTS = 8,
    VT_SIMULATION_PROPERTIES = 10,
    VT_STITCHING_PROPERTIES = 12,
    VT_MESHING_PROPERTIES = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<Garment>> *garments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Garment>> *>(VT_GARMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Obstacle>> *obstacles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Obstacle>> *>(VT_OBSTACLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Constraint>> *constraints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Constraint>> *>(VT_CONSTRAINTS);
  }
  const SimulationProperties *simulation_properties() const {
    return GetPointer<const SimulationProperties *>(VT_SIMULATION_PROPERTIES);
  }
  const StichingProperties *stitching_properties() const {
    return GetPointer<const StichingProperties *>(VT_STITCHING_PROPERTIES);
  }
  const MeshingProperties *meshing_properties() const {
    return GetPointer<const MeshingProperties *>(VT_MESHING_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GARMENTS) &&
           verifier.Verify(garments()) &&
           verifier.VerifyVectorOfTables(garments()) &&
           VerifyOffset(verifier, VT_OBSTACLES) &&
           verifier.Verify(obstacles()) &&
           verifier.VerifyVectorOfTables(obstacles()) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.Verify(constraints()) &&
           verifier.VerifyVectorOfTables(constraints()) &&
           VerifyOffset(verifier, VT_SIMULATION_PROPERTIES) &&
           verifier.VerifyTable(simulation_properties()) &&
           VerifyOffset(verifier, VT_STITCHING_PROPERTIES) &&
           verifier.VerifyTable(stitching_properties()) &&
           VerifyOffset(verifier, VT_MESHING_PROPERTIES) &&
           verifier.VerifyTable(meshing_properties()) &&
           verifier.EndTable();
  }
  SceneT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SceneT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Scene> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SceneT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_garments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Garment>>> garments) {
    fbb_.AddOffset(Scene::VT_GARMENTS, garments);
  }
  void add_obstacles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Obstacle>>> obstacles) {
    fbb_.AddOffset(Scene::VT_OBSTACLES, obstacles);
  }
  void add_constraints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Constraint>>> constraints) {
    fbb_.AddOffset(Scene::VT_CONSTRAINTS, constraints);
  }
  void add_simulation_properties(flatbuffers::Offset<SimulationProperties> simulation_properties) {
    fbb_.AddOffset(Scene::VT_SIMULATION_PROPERTIES, simulation_properties);
  }
  void add_stitching_properties(flatbuffers::Offset<StichingProperties> stitching_properties) {
    fbb_.AddOffset(Scene::VT_STITCHING_PROPERTIES, stitching_properties);
  }
  void add_meshing_properties(flatbuffers::Offset<MeshingProperties> meshing_properties) {
    fbb_.AddOffset(Scene::VT_MESHING_PROPERTIES, meshing_properties);
  }
  explicit SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scene>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Garment>>> garments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Obstacle>>> obstacles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Constraint>>> constraints = 0,
    flatbuffers::Offset<SimulationProperties> simulation_properties = 0,
    flatbuffers::Offset<StichingProperties> stitching_properties = 0,
    flatbuffers::Offset<MeshingProperties> meshing_properties = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_meshing_properties(meshing_properties);
  builder_.add_stitching_properties(stitching_properties);
  builder_.add_simulation_properties(simulation_properties);
  builder_.add_constraints(constraints);
  builder_.add_obstacles(obstacles);
  builder_.add_garments(garments);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scene> CreateSceneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Garment>> *garments = nullptr,
    const std::vector<flatbuffers::Offset<Obstacle>> *obstacles = nullptr,
    const std::vector<flatbuffers::Offset<Constraint>> *constraints = nullptr,
    flatbuffers::Offset<SimulationProperties> simulation_properties = 0,
    flatbuffers::Offset<StichingProperties> stitching_properties = 0,
    flatbuffers::Offset<MeshingProperties> meshing_properties = 0) {
  return ARCSim::CreateScene(
      _fbb,
      garments ? _fbb.CreateVector<flatbuffers::Offset<Garment>>(*garments) : 0,
      obstacles ? _fbb.CreateVector<flatbuffers::Offset<Obstacle>>(*obstacles) : 0,
      constraints ? _fbb.CreateVector<flatbuffers::Offset<Constraint>>(*constraints) : 0,
      simulation_properties,
      stitching_properties,
      meshing_properties);
}

flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb, const SceneT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GeometryDataVertexT *GeometryDataVertex::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GeometryDataVertexT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GeometryDataVertex::UnPackTo(GeometryDataVertexT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = vertices_ws(); if (_e) { _o->vertices_ws.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertices_ws[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<GeometryDataVertex> GeometryDataVertex::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataVertexT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeometryDataVertex(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeometryDataVertex> CreateGeometryDataVertex(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataVertexT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeometryDataVertexT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _vertices_ws = _o->vertices_ws.size() ? _fbb.CreateVector(_o->vertices_ws) : 0;
  return ARCSim::CreateGeometryDataVertex(
      _fbb,
      _type,
      _vertices_ws);
}

inline GeometryDataFaceT *GeometryDataFace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GeometryDataFaceT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GeometryDataFace::UnPackTo(GeometryDataFaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = faces(); if (_e) { _o->faces.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->faces[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<GeometryDataFace> GeometryDataFace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataFaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeometryDataFace(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeometryDataFace> CreateGeometryDataFace(flatbuffers::FlatBufferBuilder &_fbb, const GeometryDataFaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeometryDataFaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _faces = _o->faces.size() ? _fbb.CreateVector(_o->faces) : 0;
  return ARCSim::CreateGeometryDataFace(
      _fbb,
      _type,
      _faces);
}

inline FaceT *Face::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FaceT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Face::UnPackTo(FaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tri_ws(); if (_e) _o->tri_ws = std::unique_ptr<Triangle>(new Triangle(*_e)); };
  { auto _e = tri_ms(); if (_e) _o->tri_ms = std::unique_ptr<Triangle>(new Triangle(*_e)); };
  { auto _e = tri_tx_chns(); if (_e) { _o->tri_tx_chns.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tri_tx_chns[_i] = *_e->Get(_i); } } };
}

inline flatbuffers::Offset<Face> Face::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFace(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Face> CreateFace(flatbuffers::FlatBufferBuilder &_fbb, const FaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tri_ws = _o->tri_ws ? _o->tri_ws.get() : 0;
  auto _tri_ms = _o->tri_ms ? _o->tri_ms.get() : 0;
  auto _tri_tx_chns = _o->tri_tx_chns.size() ? _fbb.CreateVectorOfStructs(_o->tri_tx_chns) : 0;
  return ARCSim::CreateFace(
      _fbb,
      _tri_ws,
      _tri_ms,
      _tri_tx_chns);
}

inline CurveT *Curve::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CurveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Curve::UnPackTo(CurveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = control_points(); if (_e) { _o->control_points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->control_points[_i] = *_e->Get(_i); } } };
  { auto _e = edge_treatment(); _o->edge_treatment = _e; };
}

inline flatbuffers::Offset<Curve> Curve::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CurveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCurve(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Curve> CreateCurve(flatbuffers::FlatBufferBuilder &_fbb, const CurveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CurveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _control_points = _o->control_points.size() ? _fbb.CreateVectorOfStructs(_o->control_points) : 0;
  auto _edge_treatment = _o->edge_treatment;
  return ARCSim::CreateCurve(
      _fbb,
      _type,
      _name,
      _control_points,
      _edge_treatment);
}

inline WorldSpaceCoordinatesT *WorldSpaceCoordinates::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WorldSpaceCoordinatesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WorldSpaceCoordinates::UnPackTo(WorldSpaceCoordinatesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vertices(); if (_e) { _o->vertices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertices[_i] = *_e->Get(_i); } } };
}

inline flatbuffers::Offset<WorldSpaceCoordinates> WorldSpaceCoordinates::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WorldSpaceCoordinatesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWorldSpaceCoordinates(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WorldSpaceCoordinates> CreateWorldSpaceCoordinates(flatbuffers::FlatBufferBuilder &_fbb, const WorldSpaceCoordinatesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WorldSpaceCoordinatesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vertices = _o->vertices.size() ? _fbb.CreateVectorOfStructs(_o->vertices) : 0;
  return ARCSim::CreateWorldSpaceCoordinates(
      _fbb,
      _vertices);
}

inline MaterialSpaceCoordinatesT *MaterialSpaceCoordinates::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MaterialSpaceCoordinatesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MaterialSpaceCoordinates::UnPackTo(MaterialSpaceCoordinatesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vertices(); if (_e) { _o->vertices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertices[_i] = *_e->Get(_i); } } };
}

inline flatbuffers::Offset<MaterialSpaceCoordinates> MaterialSpaceCoordinates::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaterialSpaceCoordinatesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaterialSpaceCoordinates(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaterialSpaceCoordinates> CreateMaterialSpaceCoordinates(flatbuffers::FlatBufferBuilder &_fbb, const MaterialSpaceCoordinatesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaterialSpaceCoordinatesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vertices = _o->vertices.size() ? _fbb.CreateVectorOfStructs(_o->vertices) : 0;
  return ARCSim::CreateMaterialSpaceCoordinates(
      _fbb,
      _vertices);
}

inline GeometryT *Geometry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GeometryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Geometry::UnPackTo(GeometryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vertices_ws(); if (_e) _o->vertices_ws = std::unique_ptr<WorldSpaceCoordinatesT>(_e->UnPack(_resolver)); };
  { auto _e = vertices_ms(); if (_e) _o->vertices_ms = std::unique_ptr<MaterialSpaceCoordinatesT>(_e->UnPack(_resolver)); };
  { auto _e = texture_channels(); if (_e) { _o->texture_channels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->texture_channels[_i] = std::unique_ptr<MaterialSpaceCoordinatesT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = faces(); if (_e) { _o->faces.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->faces[_i] = std::unique_ptr<FaceT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Geometry> Geometry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeometryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeometry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Geometry> CreateGeometry(flatbuffers::FlatBufferBuilder &_fbb, const GeometryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeometryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vertices_ws = _o->vertices_ws ? CreateWorldSpaceCoordinates(_fbb, _o->vertices_ws.get(), _rehasher) : 0;
  auto _vertices_ms = _o->vertices_ms ? CreateMaterialSpaceCoordinates(_fbb, _o->vertices_ms.get(), _rehasher) : 0;
  auto _texture_channels = _o->texture_channels.size() ? _fbb.CreateVector<flatbuffers::Offset<MaterialSpaceCoordinates>> (_o->texture_channels.size(), [](size_t i, _VectorArgs *__va) { return CreateMaterialSpaceCoordinates(*__va->__fbb, __va->__o->texture_channels[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _faces = _o->faces.size() ? _fbb.CreateVector<flatbuffers::Offset<Face>> (_o->faces.size(), [](size_t i, _VectorArgs *__va) { return CreateFace(*__va->__fbb, __va->__o->faces[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreateGeometry(
      _fbb,
      _vertices_ws,
      _vertices_ms,
      _texture_channels,
      _faces);
}

inline FoldT *Fold::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FoldT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Fold::UnPackTo(FoldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = curve(); _o->curve = _e; };
  { auto _e = angle(); _o->angle = _e; };
  { auto _e = start_angle(); _o->start_angle = _e; };
  { auto _e = end_angle(); _o->end_angle = _e; };
}

inline flatbuffers::Offset<Fold> Fold::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FoldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFold(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Fold> CreateFold(flatbuffers::FlatBufferBuilder &_fbb, const FoldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FoldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _curve = _o->curve;
  auto _angle = _o->angle;
  auto _start_angle = _o->start_angle;
  auto _end_angle = _o->end_angle;
  return ARCSim::CreateFold(
      _fbb,
      _type,
      _curve,
      _angle,
      _start_angle,
      _end_angle);
}

inline CurveMapT *CurveMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CurveMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CurveMap::UnPackTo(CurveMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vertices_ms(); if (_e) { _o->vertices_ms.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertices_ms[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<CurveMap> CurveMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CurveMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCurveMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CurveMap> CreateCurveMap(flatbuffers::FlatBufferBuilder &_fbb, const CurveMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CurveMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vertices_ms = _o->vertices_ms.size() ? _fbb.CreateVector(_o->vertices_ms) : 0;
  return ARCSim::CreateCurveMap(
      _fbb,
      _vertices_ms);
}

inline PieceMapT *PieceMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PieceMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PieceMap::UnPackTo(PieceMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vertices_ms(); if (_e) { _o->vertices_ms.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertices_ms[_i] = _e->Get(_i); } } };
  { auto _e = curve_maps(); if (_e) { _o->curve_maps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->curve_maps[_i] = std::unique_ptr<CurveMapT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<PieceMap> PieceMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PieceMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePieceMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PieceMap> CreatePieceMap(flatbuffers::FlatBufferBuilder &_fbb, const PieceMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PieceMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vertices_ms = _o->vertices_ms.size() ? _fbb.CreateVector(_o->vertices_ms) : 0;
  auto _curve_maps = _o->curve_maps.size() ? _fbb.CreateVector<flatbuffers::Offset<CurveMap>> (_o->curve_maps.size(), [](size_t i, _VectorArgs *__va) { return CreateCurveMap(*__va->__fbb, __va->__o->curve_maps[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreatePieceMap(
      _fbb,
      _vertices_ms,
      _curve_maps);
}

inline PieceT *Piece::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PieceT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Piece::UnPackTo(PieceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = curves(); if (_e) { _o->curves.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->curves[_i] = std::unique_ptr<CurveT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = boundary(); if (_e) { _o->boundary.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boundary[_i] = _e->Get(_i); } } };
  { auto _e = folds(); if (_e) { _o->folds.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->folds[_i] = std::unique_ptr<FoldT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = fabric(); _o->fabric = _e; };
  { auto _e = extrusion_thickness(); _o->extrusion_thickness = _e; };
}

inline flatbuffers::Offset<Piece> Piece::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PieceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePiece(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Piece> CreatePiece(flatbuffers::FlatBufferBuilder &_fbb, const PieceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PieceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _curves = _o->curves.size() ? _fbb.CreateVector<flatbuffers::Offset<Curve>> (_o->curves.size(), [](size_t i, _VectorArgs *__va) { return CreateCurve(*__va->__fbb, __va->__o->curves[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _boundary = _o->boundary.size() ? _fbb.CreateVector(_o->boundary) : 0;
  auto _folds = _o->folds.size() ? _fbb.CreateVector<flatbuffers::Offset<Fold>> (_o->folds.size(), [](size_t i, _VectorArgs *__va) { return CreateFold(*__va->__fbb, __va->__o->folds[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _fabric = _o->fabric;
  auto _extrusion_thickness = _o->extrusion_thickness;
  return ARCSim::CreatePiece(
      _fbb,
      _name,
      _curves,
      _boundary,
      _folds,
      _fabric,
      _extrusion_thickness);
}

inline SeamT *Seam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SeamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Seam::UnPackTo(SeamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = piece_a(); _o->piece_a = _e; };
  { auto _e = curve_a(); _o->curve_a = _e; };
  { auto _e = piece_b(); _o->piece_b = _e; };
  { auto _e = curve_b(); _o->curve_b = _e; };
  { auto _e = reversed(); _o->reversed = _e; };
  { auto _e = seam_angle(); _o->seam_angle = _e; };
}

inline flatbuffers::Offset<Seam> Seam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSeam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Seam> CreateSeam(flatbuffers::FlatBufferBuilder &_fbb, const SeamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SeamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _piece_a = _o->piece_a;
  auto _curve_a = _o->curve_a;
  auto _piece_b = _o->piece_b;
  auto _curve_b = _o->curve_b;
  auto _reversed = _o->reversed;
  auto _seam_angle = _o->seam_angle;
  return ARCSim::CreateSeam(
      _fbb,
      _piece_a,
      _curve_a,
      _piece_b,
      _curve_b,
      _reversed,
      _seam_angle);
}

inline AvametricV1FabricT *AvametricV1Fabric::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AvametricV1FabricT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AvametricV1Fabric::UnPackTo(AvametricV1FabricT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = density(); _o->density = _e; };
  { auto _e = basetype(); _o->basetype = _e; };
  { auto _e = stretch_c11(); _o->stretch_c11 = _e; };
  { auto _e = stretch_c12(); _o->stretch_c12 = _e; };
  { auto _e = stretch_c22(); _o->stretch_c22 = _e; };
  { auto _e = stretch_c33(); _o->stretch_c33 = _e; };
  { auto _e = bending(); _o->bending = _e; };
}

inline flatbuffers::Offset<AvametricV1Fabric> AvametricV1Fabric::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvametricV1FabricT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAvametricV1Fabric(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AvametricV1Fabric> CreateAvametricV1Fabric(flatbuffers::FlatBufferBuilder &_fbb, const AvametricV1FabricT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AvametricV1FabricT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _density = _o->density;
  auto _basetype = _o->basetype;
  auto _stretch_c11 = _o->stretch_c11;
  auto _stretch_c12 = _o->stretch_c12;
  auto _stretch_c22 = _o->stretch_c22;
  auto _stretch_c33 = _o->stretch_c33;
  auto _bending = _o->bending;
  return ARCSim::CreateAvametricV1Fabric(
      _fbb,
      _density,
      _basetype,
      _stretch_c11,
      _stretch_c12,
      _stretch_c22,
      _stretch_c33,
      _bending);
}

inline GerberFabricT *GerberFabric::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GerberFabricT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GerberFabric::UnPackTo(GerberFabricT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = density(); _o->density = _e; };
  { auto _e = stretch_x(); _o->stretch_x = _e; };
  { auto _e = stretch_y(); _o->stretch_y = _e; };
  { auto _e = stretch_bias(); _o->stretch_bias = _e; };
  { auto _e = bending_x(); _o->bending_x = _e; };
  { auto _e = bending_y(); _o->bending_y = _e; };
  { auto _e = bending_bias(); _o->bending_bias = _e; };
}

inline flatbuffers::Offset<GerberFabric> GerberFabric::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GerberFabricT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGerberFabric(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GerberFabric> CreateGerberFabric(flatbuffers::FlatBufferBuilder &_fbb, const GerberFabricT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GerberFabricT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _density = _o->density;
  auto _stretch_x = _o->stretch_x;
  auto _stretch_y = _o->stretch_y;
  auto _stretch_bias = _o->stretch_bias;
  auto _bending_x = _o->bending_x;
  auto _bending_y = _o->bending_y;
  auto _bending_bias = _o->bending_bias;
  return ARCSim::CreateGerberFabric(
      _fbb,
      _density,
      _stretch_x,
      _stretch_y,
      _stretch_bias,
      _bending_x,
      _bending_y,
      _bending_bias);
}

inline SimpleAnisotropicFabricT *SimpleAnisotropicFabric::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SimpleAnisotropicFabricT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SimpleAnisotropicFabric::UnPackTo(SimpleAnisotropicFabricT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = density(); _o->density = _e; };
  { auto _e = youngs_modulus_x(); _o->youngs_modulus_x = _e; };
  { auto _e = youngs_modulus_y(); _o->youngs_modulus_y = _e; };
  { auto _e = poissons_ratio(); _o->poissons_ratio = _e; };
  { auto _e = shear_modulus(); _o->shear_modulus = _e; };
  { auto _e = bending_x(); _o->bending_x = _e; };
  { auto _e = bending_y(); _o->bending_y = _e; };
  { auto _e = bending_bias(); _o->bending_bias = _e; };
}

inline flatbuffers::Offset<SimpleAnisotropicFabric> SimpleAnisotropicFabric::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimpleAnisotropicFabricT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSimpleAnisotropicFabric(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SimpleAnisotropicFabric> CreateSimpleAnisotropicFabric(flatbuffers::FlatBufferBuilder &_fbb, const SimpleAnisotropicFabricT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SimpleAnisotropicFabricT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _density = _o->density;
  auto _youngs_modulus_x = _o->youngs_modulus_x;
  auto _youngs_modulus_y = _o->youngs_modulus_y;
  auto _poissons_ratio = _o->poissons_ratio;
  auto _shear_modulus = _o->shear_modulus;
  auto _bending_x = _o->bending_x;
  auto _bending_y = _o->bending_y;
  auto _bending_bias = _o->bending_bias;
  return ARCSim::CreateSimpleAnisotropicFabric(
      _fbb,
      _density,
      _youngs_modulus_x,
      _youngs_modulus_y,
      _poissons_ratio,
      _shear_modulus,
      _bending_x,
      _bending_y,
      _bending_bias);
}

inline FabricT *Fabric::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FabricT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Fabric::UnPackTo(FabricT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = avametric_v1_props(); if (_e) _o->avametric_v1_props = std::unique_ptr<AvametricV1FabricT>(_e->UnPack(_resolver)); };
  { auto _e = gerber_props(); if (_e) _o->gerber_props = std::unique_ptr<GerberFabricT>(_e->UnPack(_resolver)); };
  { auto _e = simple_anisotropic_props(); if (_e) _o->simple_anisotropic_props = std::unique_ptr<SimpleAnisotropicFabricT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Fabric> Fabric::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FabricT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFabric(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Fabric> CreateFabric(flatbuffers::FlatBufferBuilder &_fbb, const FabricT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FabricT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _avametric_v1_props = _o->avametric_v1_props ? CreateAvametricV1Fabric(_fbb, _o->avametric_v1_props.get(), _rehasher) : 0;
  auto _gerber_props = _o->gerber_props ? CreateGerberFabric(_fbb, _o->gerber_props.get(), _rehasher) : 0;
  auto _simple_anisotropic_props = _o->simple_anisotropic_props ? CreateSimpleAnisotropicFabric(_fbb, _o->simple_anisotropic_props.get(), _rehasher) : 0;
  return ARCSim::CreateFabric(
      _fbb,
      _type,
      _avametric_v1_props,
      _gerber_props,
      _simple_anisotropic_props);
}

inline GarmentFrameT *GarmentFrame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GarmentFrameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GarmentFrame::UnPackTo(GarmentFrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = geometry(); if (_e) _o->geometry = std::unique_ptr<GeometryT>(_e->UnPack(_resolver)); };
  { auto _e = vertex_data(); if (_e) { _o->vertex_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertex_data[_i] = std::unique_ptr<GeometryDataVertexT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = face_data(); if (_e) { _o->face_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->face_data[_i] = std::unique_ptr<GeometryDataFaceT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = piece_maps(); if (_e) { _o->piece_maps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->piece_maps[_i] = std::unique_ptr<PieceMapT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = subframe(); _o->subframe = _e; };
  { auto _e = timestamp(); _o->timestamp = _e; };
}

inline flatbuffers::Offset<GarmentFrame> GarmentFrame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GarmentFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGarmentFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GarmentFrame> CreateGarmentFrame(flatbuffers::FlatBufferBuilder &_fbb, const GarmentFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GarmentFrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _geometry = _o->geometry ? CreateGeometry(_fbb, _o->geometry.get(), _rehasher) : 0;
  auto _vertex_data = _o->vertex_data.size() ? _fbb.CreateVector<flatbuffers::Offset<GeometryDataVertex>> (_o->vertex_data.size(), [](size_t i, _VectorArgs *__va) { return CreateGeometryDataVertex(*__va->__fbb, __va->__o->vertex_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _face_data = _o->face_data.size() ? _fbb.CreateVector<flatbuffers::Offset<GeometryDataFace>> (_o->face_data.size(), [](size_t i, _VectorArgs *__va) { return CreateGeometryDataFace(*__va->__fbb, __va->__o->face_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _piece_maps = _o->piece_maps.size() ? _fbb.CreateVector<flatbuffers::Offset<PieceMap>> (_o->piece_maps.size(), [](size_t i, _VectorArgs *__va) { return CreatePieceMap(*__va->__fbb, __va->__o->piece_maps[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _frame = _o->frame;
  auto _subframe = _o->subframe;
  auto _timestamp = _o->timestamp;
  return ARCSim::CreateGarmentFrame(
      _fbb,
      _geometry,
      _vertex_data,
      _face_data,
      _piece_maps,
      _frame,
      _subframe,
      _timestamp);
}

inline GarmentT *Garment::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GarmentT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Garment::UnPackTo(GarmentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = initial_geometry(); if (_e) _o->initial_geometry = std::unique_ptr<GarmentFrameT>(_e->UnPack(_resolver)); };
  { auto _e = frames(); if (_e) { _o->frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frames[_i] = std::unique_ptr<GarmentFrameT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = pieces(); if (_e) { _o->pieces.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pieces[_i] = std::unique_ptr<PieceT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = seams(); if (_e) { _o->seams.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->seams[_i] = std::unique_ptr<SeamT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = fabrics(); if (_e) { _o->fabrics.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fabrics[_i] = std::unique_ptr<FabricT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Garment> Garment::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GarmentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGarment(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Garment> CreateGarment(flatbuffers::FlatBufferBuilder &_fbb, const GarmentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GarmentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _initial_geometry = _o->initial_geometry ? CreateGarmentFrame(_fbb, _o->initial_geometry.get(), _rehasher) : 0;
  auto _frames = _o->frames.size() ? _fbb.CreateVector<flatbuffers::Offset<GarmentFrame>> (_o->frames.size(), [](size_t i, _VectorArgs *__va) { return CreateGarmentFrame(*__va->__fbb, __va->__o->frames[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _pieces = _o->pieces.size() ? _fbb.CreateVector<flatbuffers::Offset<Piece>> (_o->pieces.size(), [](size_t i, _VectorArgs *__va) { return CreatePiece(*__va->__fbb, __va->__o->pieces[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _seams = _o->seams.size() ? _fbb.CreateVector<flatbuffers::Offset<Seam>> (_o->seams.size(), [](size_t i, _VectorArgs *__va) { return CreateSeam(*__va->__fbb, __va->__o->seams[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _fabrics = _o->fabrics.size() ? _fbb.CreateVector<flatbuffers::Offset<Fabric>> (_o->fabrics.size(), [](size_t i, _VectorArgs *__va) { return CreateFabric(*__va->__fbb, __va->__o->fabrics[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreateGarment(
      _fbb,
      _name,
      _initial_geometry,
      _frames,
      _pieces,
      _seams,
      _fabrics);
}

inline SdfT *Sdf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SdfT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Sdf::UnPackTo(SdfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
  { auto _e = dx(); _o->dx = _e; };
  { auto _e = innerband(); _o->innerband = _e; };
  { auto _e = outerband(); _o->outerband = _e; };
}

inline flatbuffers::Offset<Sdf> Sdf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SdfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSdf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sdf> CreateSdf(flatbuffers::FlatBufferBuilder &_fbb, const SdfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SdfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _dx = _o->dx;
  auto _innerband = _o->innerband;
  auto _outerband = _o->outerband;
  return ARCSim::CreateSdf(
      _fbb,
      _data,
      _dx,
      _innerband,
      _outerband);
}

inline ObstacleFrameT *ObstacleFrame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ObstacleFrameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ObstacleFrame::UnPackTo(ObstacleFrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = geometry(); if (_e) _o->geometry = std::unique_ptr<GeometryT>(_e->UnPack(_resolver)); };
  { auto _e = sdf_parts(); if (_e) { _o->sdf_parts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sdf_parts[_i] = std::unique_ptr<SdfT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = subframe(); _o->subframe = _e; };
  { auto _e = timestamp(); _o->timestamp = _e; };
}

inline flatbuffers::Offset<ObstacleFrame> ObstacleFrame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObstacleFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ObstacleFrame> CreateObstacleFrame(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObstacleFrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _geometry = _o->geometry ? CreateGeometry(_fbb, _o->geometry.get(), _rehasher) : 0;
  auto _sdf_parts = _o->sdf_parts.size() ? _fbb.CreateVector<flatbuffers::Offset<Sdf>> (_o->sdf_parts.size(), [](size_t i, _VectorArgs *__va) { return CreateSdf(*__va->__fbb, __va->__o->sdf_parts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _frame = _o->frame;
  auto _subframe = _o->subframe;
  auto _timestamp = _o->timestamp;
  return ARCSim::CreateObstacleFrame(
      _fbb,
      _geometry,
      _sdf_parts,
      _frame,
      _subframe,
      _timestamp);
}

inline ObstacleT *Obstacle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ObstacleT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Obstacle::UnPackTo(ObstacleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = initial_geometry(); if (_e) _o->initial_geometry = std::unique_ptr<GeometryT>(_e->UnPack(_resolver)); };
  { auto _e = frames(); if (_e) { _o->frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frames[_i] = std::unique_ptr<ObstacleFrameT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Obstacle> Obstacle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObstacle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Obstacle> CreateObstacle(flatbuffers::FlatBufferBuilder &_fbb, const ObstacleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObstacleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _initial_geometry = _o->initial_geometry ? CreateGeometry(_fbb, _o->initial_geometry.get(), _rehasher) : 0;
  auto _frames = _o->frames.size() ? _fbb.CreateVector<flatbuffers::Offset<ObstacleFrame>> (_o->frames.size(), [](size_t i, _VectorArgs *__va) { return CreateObstacleFrame(*__va->__fbb, __va->__o->frames[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreateObstacle(
      _fbb,
      _name,
      _initial_geometry,
      _frames);
}

inline StandardConstraintPropertiesT *StandardConstraintProperties::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StandardConstraintPropertiesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StandardConstraintProperties::UnPackTo(StandardConstraintPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = stiffness(); _o->stiffness = _e; };
  { auto _e = start_frame(); _o->start_frame = _e; };
  { auto _e = end_frame(); _o->end_frame = _e; };
}

inline flatbuffers::Offset<StandardConstraintProperties> StandardConstraintProperties::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StandardConstraintPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStandardConstraintProperties(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StandardConstraintProperties> CreateStandardConstraintProperties(flatbuffers::FlatBufferBuilder &_fbb, const StandardConstraintPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StandardConstraintPropertiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _stiffness = _o->stiffness;
  auto _start_frame = _o->start_frame;
  auto _end_frame = _o->end_frame;
  return ARCSim::CreateStandardConstraintProperties(
      _fbb,
      _name,
      _stiffness,
      _start_frame,
      _end_frame);
}

inline AttachmentsNodeT *AttachmentsNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentsNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentsNode::UnPackTo(AttachmentsNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attachments(); if (_e) { _o->attachments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attachments[_i] = *_e->Get(_i); } } };
}

inline flatbuffers::Offset<AttachmentsNode> AttachmentsNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentsNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentsNode> CreateAttachmentsNode(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentsNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attachments = _o->attachments.size() ? _fbb.CreateVectorOfStructs(_o->attachments) : 0;
  return ARCSim::CreateAttachmentsNode(
      _fbb,
      _attachments);
}

inline AttachmentsEdgeT *AttachmentsEdge::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentsEdgeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentsEdge::UnPackTo(AttachmentsEdgeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attachments(); if (_e) { _o->attachments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attachments[_i] = *_e->Get(_i); } } };
}

inline flatbuffers::Offset<AttachmentsEdge> AttachmentsEdge::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsEdgeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentsEdge(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentsEdge> CreateAttachmentsEdge(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsEdgeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentsEdgeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attachments = _o->attachments.size() ? _fbb.CreateVectorOfStructs(_o->attachments) : 0;
  return ARCSim::CreateAttachmentsEdge(
      _fbb,
      _attachments);
}

inline AttachmentMsT *AttachmentMs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentMsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentMs::UnPackTo(AttachmentMsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ms_loc(); if (_e) _o->ms_loc = std::unique_ptr<Vec2>(new Vec2(*_e)); };
}

inline flatbuffers::Offset<AttachmentMs> AttachmentMs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentMsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentMs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentMs> CreateAttachmentMs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentMsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentMsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ms_loc = _o->ms_loc ? _o->ms_loc.get() : 0;
  return ARCSim::CreateAttachmentMs(
      _fbb,
      _ms_loc);
}

inline AttachmentsMsT *AttachmentsMs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentsMsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentsMs::UnPackTo(AttachmentsMsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attachments(); if (_e) { _o->attachments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attachments[_i] = std::unique_ptr<AttachmentMsT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AttachmentsMs> AttachmentsMs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsMsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentsMs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentsMs> CreateAttachmentsMs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsMsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentsMsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attachments = _o->attachments.size() ? _fbb.CreateVector<flatbuffers::Offset<AttachmentMs>> (_o->attachments.size(), [](size_t i, _VectorArgs *__va) { return CreateAttachmentMs(*__va->__fbb, __va->__o->attachments[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreateAttachmentsMs(
      _fbb,
      _attachments);
}

inline AttachmentWsT *AttachmentWs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentWsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentWs::UnPackTo(AttachmentWsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ws_loc(); if (_e) _o->ws_loc = std::unique_ptr<Vec3>(new Vec3(*_e)); };
}

inline flatbuffers::Offset<AttachmentWs> AttachmentWs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentWsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentWs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentWs> CreateAttachmentWs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentWsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentWsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ws_loc = _o->ws_loc ? _o->ws_loc.get() : 0;
  return ARCSim::CreateAttachmentWs(
      _fbb,
      _ws_loc);
}

inline AttachmentsWsT *AttachmentsWs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentsWsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentsWs::UnPackTo(AttachmentsWsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attachments(); if (_e) { _o->attachments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attachments[_i] = std::unique_ptr<AttachmentWsT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AttachmentsWs> AttachmentsWs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsWsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentsWs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentsWs> CreateAttachmentsWs(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsWsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentsWsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attachments = _o->attachments.size() ? _fbb.CreateVector<flatbuffers::Offset<AttachmentWs>> (_o->attachments.size(), [](size_t i, _VectorArgs *__va) { return CreateAttachmentWs(*__va->__fbb, __va->__o->attachments[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreateAttachmentsWs(
      _fbb,
      _attachments);
}

inline AttachmentUVT *AttachmentUV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentUVT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentUV::UnPackTo(AttachmentUVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uv_loc(); if (_e) _o->uv_loc = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = channel(); _o->channel = _e; };
}

inline flatbuffers::Offset<AttachmentUV> AttachmentUV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentUVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentUV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentUV> CreateAttachmentUV(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentUVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentUVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uv_loc = _o->uv_loc ? _o->uv_loc.get() : 0;
  auto _channel = _o->channel;
  return ARCSim::CreateAttachmentUV(
      _fbb,
      _uv_loc,
      _channel);
}

inline AttachmentsUVT *AttachmentsUV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentsUVT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentsUV::UnPackTo(AttachmentsUVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attachments(); if (_e) { _o->attachments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attachments[_i] = std::unique_ptr<AttachmentUVT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AttachmentsUV> AttachmentsUV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsUVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentsUV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentsUV> CreateAttachmentsUV(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsUVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentsUVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attachments = _o->attachments.size() ? _fbb.CreateVector<flatbuffers::Offset<AttachmentUV>> (_o->attachments.size(), [](size_t i, _VectorArgs *__va) { return CreateAttachmentUV(*__va->__fbb, __va->__o->attachments[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreateAttachmentsUV(
      _fbb,
      _attachments);
}

inline AttachmentBaryT *AttachmentBary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentBaryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentBary::UnPackTo(AttachmentBaryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = barycentric_coords(); if (_e) _o->barycentric_coords = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = face(); _o->face = _e; };
}

inline flatbuffers::Offset<AttachmentBary> AttachmentBary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentBaryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentBary(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentBary> CreateAttachmentBary(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentBaryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentBaryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _barycentric_coords = _o->barycentric_coords ? _o->barycentric_coords.get() : 0;
  auto _face = _o->face;
  return ARCSim::CreateAttachmentBary(
      _fbb,
      _barycentric_coords,
      _face);
}

inline AttachmentsBaryT *AttachmentsBary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttachmentsBaryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttachmentsBary::UnPackTo(AttachmentsBaryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attachments(); if (_e) { _o->attachments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attachments[_i] = std::unique_ptr<AttachmentBaryT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AttachmentsBary> AttachmentsBary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsBaryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttachmentsBary(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttachmentsBary> CreateAttachmentsBary(flatbuffers::FlatBufferBuilder &_fbb, const AttachmentsBaryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttachmentsBaryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attachments = _o->attachments.size() ? _fbb.CreateVector<flatbuffers::Offset<AttachmentBary>> (_o->attachments.size(), [](size_t i, _VectorArgs *__va) { return CreateAttachmentBary(*__va->__fbb, __va->__o->attachments[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ARCSim::CreateAttachmentsBary(
      _fbb,
      _attachments);
}

inline NodeConstraintT *NodeConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NodeConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NodeConstraint::UnPackTo(NodeConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsNodeT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<NodeConstraint> NodeConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNodeConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NodeConstraint> CreateNodeConstraint(flatbuffers::FlatBufferBuilder &_fbb, const NodeConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NodeConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsNode(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  return ARCSim::CreateNodeConstraint(
      _fbb,
      _cloth_attachment);
}

inline ForceConstraintT *ForceConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ForceConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ForceConstraint::UnPackTo(ForceConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = cloth_attachment_type(); _o->cloth_attachment.type = _e; };
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment.value = ClothAttachmentUnion::UnPack(_e, cloth_attachment_type(), _resolver); };
}

inline flatbuffers::Offset<ForceConstraint> ForceConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ForceConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateForceConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ForceConstraint> CreateForceConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ForceConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ForceConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _direction = _o->direction ? _o->direction.get() : 0;
  auto _cloth_attachment_type = _o->cloth_attachment.type;
  auto _cloth_attachment = _o->cloth_attachment.Pack(_fbb);
  return ARCSim::CreateForceConstraint(
      _fbb,
      _direction,
      _cloth_attachment_type,
      _cloth_attachment);
}

inline PinConstraintT *PinConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PinConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PinConstraint::UnPackTo(PinConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slack(); _o->slack = _e; };
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsMsT>(_e->UnPack(_resolver)); };
  { auto _e = body_attachment_type(); _o->body_attachment.type = _e; };
  { auto _e = body_attachment(); if (_e) _o->body_attachment.value = ObstacleAttachmentUnion::UnPack(_e, body_attachment_type(), _resolver); };
}

inline flatbuffers::Offset<PinConstraint> PinConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PinConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePinConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PinConstraint> CreatePinConstraint(flatbuffers::FlatBufferBuilder &_fbb, const PinConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PinConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slack = _o->slack;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsMs(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  auto _body_attachment_type = _o->body_attachment.type;
  auto _body_attachment = _o->body_attachment.Pack(_fbb);
  return ARCSim::CreatePinConstraint(
      _fbb,
      _slack,
      _cloth_attachment,
      _body_attachment_type,
      _body_attachment);
}

inline CenteringConstraintT *CenteringConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CenteringConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CenteringConstraint::UnPackTo(CenteringConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsEdgeT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CenteringConstraint> CenteringConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CenteringConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCenteringConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CenteringConstraint> CreateCenteringConstraint(flatbuffers::FlatBufferBuilder &_fbb, const CenteringConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CenteringConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsEdge(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  return ARCSim::CreateCenteringConstraint(
      _fbb,
      _cloth_attachment);
}

inline BarrierConstraintT *BarrierConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BarrierConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BarrierConstraint::UnPackTo(BarrierConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = animate_normal(); _o->animate_normal = _e; };
  { auto _e = normal(); if (_e) _o->normal = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsEdgeT>(_e->UnPack(_resolver)); };
  { auto _e = body_attachment_type(); _o->body_attachment.type = _e; };
  { auto _e = body_attachment(); if (_e) _o->body_attachment.value = ObstacleAttachmentUnion::UnPack(_e, body_attachment_type(), _resolver); };
}

inline flatbuffers::Offset<BarrierConstraint> BarrierConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBarrierConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BarrierConstraint> CreateBarrierConstraint(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BarrierConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _animate_normal = _o->animate_normal;
  auto _normal = _o->normal ? _o->normal.get() : 0;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsEdge(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  auto _body_attachment_type = _o->body_attachment.type;
  auto _body_attachment = _o->body_attachment.Pack(_fbb);
  return ARCSim::CreateBarrierConstraint(
      _fbb,
      _animate_normal,
      _normal,
      _cloth_attachment,
      _body_attachment_type,
      _body_attachment);
}

inline BeltConstraintT *BeltConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BeltConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BeltConstraint::UnPackTo(BeltConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slack(); _o->slack = _e; };
  { auto _e = animate_normal(); _o->animate_normal = _e; };
  { auto _e = normal(); if (_e) _o->normal = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsEdgeT>(_e->UnPack(_resolver)); };
  { auto _e = body_attachment_type(); _o->body_attachment.type = _e; };
  { auto _e = body_attachment(); if (_e) _o->body_attachment.value = ObstacleAttachmentUnion::UnPack(_e, body_attachment_type(), _resolver); };
}

inline flatbuffers::Offset<BeltConstraint> BeltConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BeltConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBeltConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BeltConstraint> CreateBeltConstraint(flatbuffers::FlatBufferBuilder &_fbb, const BeltConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BeltConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slack = _o->slack;
  auto _animate_normal = _o->animate_normal;
  auto _normal = _o->normal ? _o->normal.get() : 0;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsEdge(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  auto _body_attachment_type = _o->body_attachment.type;
  auto _body_attachment = _o->body_attachment.Pack(_fbb);
  return ARCSim::CreateBeltConstraint(
      _fbb,
      _slack,
      _animate_normal,
      _normal,
      _cloth_attachment,
      _body_attachment_type,
      _body_attachment);
}

inline ElasticConstraintT *ElasticConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ElasticConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ElasticConstraint::UnPackTo(ElasticConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_length(); _o->target_length = _e; };
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsEdgeT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ElasticConstraint> ElasticConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElasticConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElasticConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ElasticConstraint> CreateElasticConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ElasticConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ElasticConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_length = _o->target_length;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsEdge(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  return ARCSim::CreateElasticConstraint(
      _fbb,
      _target_length,
      _cloth_attachment);
}

inline ButtonConstraintT *ButtonConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ButtonConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ButtonConstraint::UnPackTo(ButtonConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsMsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ButtonConstraint> ButtonConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ButtonConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateButtonConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ButtonConstraint> CreateButtonConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ButtonConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ButtonConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsMs(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  return ARCSim::CreateButtonConstraint(
      _fbb,
      _cloth_attachment);
}

inline OrientedButtonConstraintT *OrientedButtonConstraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OrientedButtonConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OrientedButtonConstraint::UnPackTo(OrientedButtonConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cloth_attachment(); if (_e) _o->cloth_attachment = std::unique_ptr<AttachmentsMsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<OrientedButtonConstraint> OrientedButtonConstraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrientedButtonConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOrientedButtonConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OrientedButtonConstraint> CreateOrientedButtonConstraint(flatbuffers::FlatBufferBuilder &_fbb, const OrientedButtonConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OrientedButtonConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cloth_attachment = _o->cloth_attachment ? CreateAttachmentsMs(_fbb, _o->cloth_attachment.get(), _rehasher) : 0;
  return ARCSim::CreateOrientedButtonConstraint(
      _fbb,
      _cloth_attachment);
}

inline ConstraintT *Constraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConstraintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Constraint::UnPackTo(ConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = standard_props(); if (_e) _o->standard_props = std::unique_ptr<StandardConstraintPropertiesT>(_e->UnPack(_resolver)); };
  { auto _e = node(); if (_e) _o->node = std::unique_ptr<NodeConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = force(); if (_e) _o->force = std::unique_ptr<ForceConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = pin(); if (_e) _o->pin = std::unique_ptr<PinConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = centering(); if (_e) _o->centering = std::unique_ptr<CenteringConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = barrier(); if (_e) _o->barrier = std::unique_ptr<BarrierConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = belt(); if (_e) _o->belt = std::unique_ptr<BeltConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = elastic(); if (_e) _o->elastic = std::unique_ptr<ElasticConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = button(); if (_e) _o->button = std::unique_ptr<ButtonConstraintT>(_e->UnPack(_resolver)); };
  { auto _e = oriented_button(); if (_e) _o->oriented_button = std::unique_ptr<OrientedButtonConstraintT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Constraint> Constraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Constraint> CreateConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _standard_props = _o->standard_props ? CreateStandardConstraintProperties(_fbb, _o->standard_props.get(), _rehasher) : 0;
  auto _node = _o->node ? CreateNodeConstraint(_fbb, _o->node.get(), _rehasher) : 0;
  auto _force = _o->force ? CreateForceConstraint(_fbb, _o->force.get(), _rehasher) : 0;
  auto _pin = _o->pin ? CreatePinConstraint(_fbb, _o->pin.get(), _rehasher) : 0;
  auto _centering = _o->centering ? CreateCenteringConstraint(_fbb, _o->centering.get(), _rehasher) : 0;
  auto _barrier = _o->barrier ? CreateBarrierConstraint(_fbb, _o->barrier.get(), _rehasher) : 0;
  auto _belt = _o->belt ? CreateBeltConstraint(_fbb, _o->belt.get(), _rehasher) : 0;
  auto _elastic = _o->elastic ? CreateElasticConstraint(_fbb, _o->elastic.get(), _rehasher) : 0;
  auto _button = _o->button ? CreateButtonConstraint(_fbb, _o->button.get(), _rehasher) : 0;
  auto _oriented_button = _o->oriented_button ? CreateOrientedButtonConstraint(_fbb, _o->oriented_button.get(), _rehasher) : 0;
  return ARCSim::CreateConstraint(
      _fbb,
      _type,
      _standard_props,
      _node,
      _force,
      _pin,
      _centering,
      _barrier,
      _belt,
      _elastic,
      _button,
      _oriented_button);
}

inline SimulationPropertiesT *SimulationProperties::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SimulationPropertiesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SimulationProperties::UnPackTo(SimulationPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SimulationProperties> SimulationProperties::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimulationPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSimulationProperties(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SimulationProperties> CreateSimulationProperties(flatbuffers::FlatBufferBuilder &_fbb, const SimulationPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SimulationPropertiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ARCSim::CreateSimulationProperties(
      _fbb);
}

inline StichingPropertiesT *StichingProperties::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StichingPropertiesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StichingProperties::UnPackTo(StichingPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<StichingProperties> StichingProperties::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StichingPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStichingProperties(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StichingProperties> CreateStichingProperties(flatbuffers::FlatBufferBuilder &_fbb, const StichingPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StichingPropertiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ARCSim::CreateStichingProperties(
      _fbb);
}

inline MeshingPropertiesT *MeshingProperties::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MeshingPropertiesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MeshingProperties::UnPackTo(MeshingPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MeshingProperties> MeshingProperties::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshingPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeshingProperties(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeshingProperties> CreateMeshingProperties(flatbuffers::FlatBufferBuilder &_fbb, const MeshingPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshingPropertiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ARCSim::CreateMeshingProperties(
      _fbb);
}

inline SceneT *Scene::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SceneT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Scene::UnPackTo(SceneT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = garments(); if (_e) { _o->garments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->garments[_i] = std::unique_ptr<GarmentT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = obstacles(); if (_e) { _o->obstacles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->obstacles[_i] = std::unique_ptr<ObstacleT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = constraints(); if (_e) { _o->constraints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->constraints[_i] = std::unique_ptr<ConstraintT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = simulation_properties(); if (_e) _o->simulation_properties = std::unique_ptr<SimulationPropertiesT>(_e->UnPack(_resolver)); };
  { auto _e = stitching_properties(); if (_e) _o->stitching_properties = std::unique_ptr<StichingPropertiesT>(_e->UnPack(_resolver)); };
  { auto _e = meshing_properties(); if (_e) _o->meshing_properties = std::unique_ptr<MeshingPropertiesT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Scene> Scene::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SceneT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScene(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb, const SceneT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SceneT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _garments = _o->garments.size() ? _fbb.CreateVector<flatbuffers::Offset<Garment>> (_o->garments.size(), [](size_t i, _VectorArgs *__va) { return CreateGarment(*__va->__fbb, __va->__o->garments[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _obstacles = _o->obstacles.size() ? _fbb.CreateVector<flatbuffers::Offset<Obstacle>> (_o->obstacles.size(), [](size_t i, _VectorArgs *__va) { return CreateObstacle(*__va->__fbb, __va->__o->obstacles[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _constraints = _o->constraints.size() ? _fbb.CreateVector<flatbuffers::Offset<Constraint>> (_o->constraints.size(), [](size_t i, _VectorArgs *__va) { return CreateConstraint(*__va->__fbb, __va->__o->constraints[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _simulation_properties = _o->simulation_properties ? CreateSimulationProperties(_fbb, _o->simulation_properties.get(), _rehasher) : 0;
  auto _stitching_properties = _o->stitching_properties ? CreateStichingProperties(_fbb, _o->stitching_properties.get(), _rehasher) : 0;
  auto _meshing_properties = _o->meshing_properties ? CreateMeshingProperties(_fbb, _o->meshing_properties.get(), _rehasher) : 0;
  return ARCSim::CreateScene(
      _fbb,
      _garments,
      _obstacles,
      _constraints,
      _simulation_properties,
      _stitching_properties,
      _meshing_properties);
}

inline bool VerifyAnyAttachment(flatbuffers::Verifier &verifier, const void *obj, AnyAttachment type) {
  switch (type) {
    case AnyAttachment::NONE: {
      return true;
    }
    case AnyAttachment::AttachmentsNode: {
      auto ptr = reinterpret_cast<const AttachmentsNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<const AttachmentsEdge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<const AttachmentsMs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyAttachment::AttachmentsWs: {
      auto ptr = reinterpret_cast<const AttachmentsWs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<const AttachmentsUV *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<const AttachmentsBary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyAttachmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyAttachment(
        verifier,  values->Get(i), types->GetEnum<AnyAttachment>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AnyAttachmentUnion::UnPack(const void *obj, AnyAttachment type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AnyAttachment::AttachmentsNode: {
      auto ptr = reinterpret_cast<const AttachmentsNode *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<const AttachmentsEdge *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<const AttachmentsMs *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyAttachment::AttachmentsWs: {
      auto ptr = reinterpret_cast<const AttachmentsWs *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<const AttachmentsUV *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<const AttachmentsBary *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AnyAttachmentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AnyAttachment::AttachmentsNode: {
      auto ptr = reinterpret_cast<const AttachmentsNodeT *>(value);
      return CreateAttachmentsNode(_fbb, ptr, _rehasher).Union();
    }
    case AnyAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<const AttachmentsEdgeT *>(value);
      return CreateAttachmentsEdge(_fbb, ptr, _rehasher).Union();
    }
    case AnyAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<const AttachmentsMsT *>(value);
      return CreateAttachmentsMs(_fbb, ptr, _rehasher).Union();
    }
    case AnyAttachment::AttachmentsWs: {
      auto ptr = reinterpret_cast<const AttachmentsWsT *>(value);
      return CreateAttachmentsWs(_fbb, ptr, _rehasher).Union();
    }
    case AnyAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<const AttachmentsUVT *>(value);
      return CreateAttachmentsUV(_fbb, ptr, _rehasher).Union();
    }
    case AnyAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<const AttachmentsBaryT *>(value);
      return CreateAttachmentsBary(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AnyAttachmentUnion::AnyAttachmentUnion(const AnyAttachmentUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case AnyAttachment::AttachmentsNode: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsNodeT not copyable.
      break;
    }
    case AnyAttachment::AttachmentsEdge: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsEdgeT not copyable.
      break;
    }
    case AnyAttachment::AttachmentsMs: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsMsT not copyable.
      break;
    }
    case AnyAttachment::AttachmentsWs: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsWsT not copyable.
      break;
    }
    case AnyAttachment::AttachmentsUV: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsUVT not copyable.
      break;
    }
    case AnyAttachment::AttachmentsBary: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsBaryT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void AnyAttachmentUnion::Reset() {
  switch (type) {
    case AnyAttachment::AttachmentsNode: {
      auto ptr = reinterpret_cast<AttachmentsNodeT *>(value);
      delete ptr;
      break;
    }
    case AnyAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<AttachmentsEdgeT *>(value);
      delete ptr;
      break;
    }
    case AnyAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<AttachmentsMsT *>(value);
      delete ptr;
      break;
    }
    case AnyAttachment::AttachmentsWs: {
      auto ptr = reinterpret_cast<AttachmentsWsT *>(value);
      delete ptr;
      break;
    }
    case AnyAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<AttachmentsUVT *>(value);
      delete ptr;
      break;
    }
    case AnyAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<AttachmentsBaryT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AnyAttachment::NONE;
}

inline bool VerifyClothAttachment(flatbuffers::Verifier &verifier, const void *obj, ClothAttachment type) {
  switch (type) {
    case ClothAttachment::NONE: {
      return true;
    }
    case ClothAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<const AttachmentsEdge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClothAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<const AttachmentsMs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyClothAttachmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyClothAttachment(
        verifier,  values->Get(i), types->GetEnum<ClothAttachment>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ClothAttachmentUnion::UnPack(const void *obj, ClothAttachment type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ClothAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<const AttachmentsEdge *>(obj);
      return ptr->UnPack(resolver);
    }
    case ClothAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<const AttachmentsMs *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ClothAttachmentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ClothAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<const AttachmentsEdgeT *>(value);
      return CreateAttachmentsEdge(_fbb, ptr, _rehasher).Union();
    }
    case ClothAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<const AttachmentsMsT *>(value);
      return CreateAttachmentsMs(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ClothAttachmentUnion::ClothAttachmentUnion(const ClothAttachmentUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ClothAttachment::AttachmentsEdge: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsEdgeT not copyable.
      break;
    }
    case ClothAttachment::AttachmentsMs: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsMsT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void ClothAttachmentUnion::Reset() {
  switch (type) {
    case ClothAttachment::AttachmentsEdge: {
      auto ptr = reinterpret_cast<AttachmentsEdgeT *>(value);
      delete ptr;
      break;
    }
    case ClothAttachment::AttachmentsMs: {
      auto ptr = reinterpret_cast<AttachmentsMsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ClothAttachment::NONE;
}

inline bool VerifyObstacleAttachment(flatbuffers::Verifier &verifier, const void *obj, ObstacleAttachment type) {
  switch (type) {
    case ObstacleAttachment::NONE: {
      return true;
    }
    case ObstacleAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<const AttachmentsUV *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObstacleAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<const AttachmentsBary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObstacleAttachmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObstacleAttachment(
        verifier,  values->Get(i), types->GetEnum<ObstacleAttachment>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ObstacleAttachmentUnion::UnPack(const void *obj, ObstacleAttachment type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ObstacleAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<const AttachmentsUV *>(obj);
      return ptr->UnPack(resolver);
    }
    case ObstacleAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<const AttachmentsBary *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ObstacleAttachmentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ObstacleAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<const AttachmentsUVT *>(value);
      return CreateAttachmentsUV(_fbb, ptr, _rehasher).Union();
    }
    case ObstacleAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<const AttachmentsBaryT *>(value);
      return CreateAttachmentsBary(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ObstacleAttachmentUnion::ObstacleAttachmentUnion(const ObstacleAttachmentUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ObstacleAttachment::AttachmentsUV: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsUVT not copyable.
      break;
    }
    case ObstacleAttachment::AttachmentsBary: {
      FLATBUFFERS_ASSERT(false);  // AttachmentsBaryT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void ObstacleAttachmentUnion::Reset() {
  switch (type) {
    case ObstacleAttachment::AttachmentsUV: {
      auto ptr = reinterpret_cast<AttachmentsUVT *>(value);
      delete ptr;
      break;
    }
    case ObstacleAttachment::AttachmentsBary: {
      auto ptr = reinterpret_cast<AttachmentsBaryT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ObstacleAttachment::NONE;
}

inline const ARCSim::Scene *GetScene(const void *buf) {
  return flatbuffers::GetRoot<ARCSim::Scene>(buf);
}

inline const ARCSim::Scene *GetSizePrefixedScene(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ARCSim::Scene>(buf);
}

inline const char *SceneIdentifier() {
  return "ASCN";
}

inline bool SceneBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, SceneIdentifier());
}

inline bool VerifySceneBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ARCSim::Scene>(SceneIdentifier());
}

inline bool VerifySizePrefixedSceneBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ARCSim::Scene>(SceneIdentifier());
}

inline const char *SceneExtension() {
  return "arcscn";
}

inline void FinishSceneBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ARCSim::Scene> root) {
  fbb.Finish(root, SceneIdentifier());
}

inline void FinishSizePrefixedSceneBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ARCSim::Scene> root) {
  fbb.FinishSizePrefixed(root, SceneIdentifier());
}

inline std::unique_ptr<SceneT> UnPackScene(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<SceneT>(GetScene(buf)->UnPack(res));
}

}  // namespace ARCSim

#endif  // FLATBUFFERS_GENERATED_ARCSIM_ARCSIM_H_
